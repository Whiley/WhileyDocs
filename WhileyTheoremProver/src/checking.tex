\chapter{Assertion Checking}

The primary goal of the Whiley Theorem Prover is to determine whether
a given assertion holds or not.  If not, then ideally a counterexample
(i.e. assignment of variables) can be generated for which the
assertion evaluates to false.  We now begin the process of exploring
how WyTP goes about doing this.  At this stage, we are still taking a
high-level view and many implementation details are left to following
chapters.

\section{Proofs}

The fundamental concept underlying WyTP is that of the {\em proof}.
Roughly speaking, a proof is a tree of information derived using one
or more {\em proof rules} from the original assertion being checked.
Proofs are checked ``by contradiction'' meaning that, for a successful
proof, every branch will be terminated with a contradiction.

\subsection{Basics}

We begin by illustrating the proofs for some simple assertions.  To
begin with, let us consider the following assertion:

\begin{lstlisting}[language=WyAL]
assert:
   forall(int x):
      if:
         x > 0
      then:
         x >= 0
\end{lstlisting}

This is a very simple assertion which, with relative ease, we can see
holds true.  By this, we mean that {\em for all possible} values of
\lstinline{x} the above formula will evaluate to \clstinline{true}.
For example, if \clstinline{x == 1} then both \clstinline{x > 0} and
\clstinline{x >= 0} evaluate to \clstinline{true} and so does the
whole formula.  Likewise, if if \clstinline{x == 1} then \clstinline{x
  > 0} evaluates to \clstinline{false} and \clstinline{x >= 0}
evaluates to \clstinline{true}, but still the whole formula evaluates
to \clstinline{true} by the rules of implication.

To understand the proof of this assertion, we must consider that it
will be a {\em proof-by-contradiction}.  That is, we will negate the
assertion and attempt to find a contradiction.  The assertion can be
expressed as the logical formula
${\tt \forall(int\;x).(x>0\implies x\ge 0)}$ and, thus, its negation
is ${\tt\exists(int\;x).(x < 0\land x\ge 0)}$.  We can now give its
proof:

\begin{wyproof}
(1) & \exists(int\;x).(x \ge 0\land x < 0) &\\
&&\\
\hline
\hline
&&\\
(2) & x_1 < 0\land x_1\ge 0 & (\exists\textrm{-elimination}, 1)\\
(3) & x_1 \ge 0 & (\land\textrm{-elimination}, 2)\\
(4) & x_1 < 0 & (\land\textrm{-elimination}, 2)\\
(5) & 0 < 0 & (\le\!\textrm{-closure}, 3 + 4)\\
(6) & \bot & (\textrm{simplification}, 5)\\
\end{wyproof}

This begins with the negated formula for a proof-by-contradiction and
each subsequent line represents some new information derived from
this.  On the left, each piece of information is given a unique ID.
Likewise, on the right, the proof rule used to derive each piece of
new information is given, along with the pieces of prior information
used.  The main piece of the proof is the use of the
$\le\!\textrm{closure}$ rule on $x_1\ge 0$ and $x_1 < 0$ to derive
$0 < 0$.  We can see that this holds by rearranging the two antecents
to give $0 \le x_1 < 0$.  Finally, the proof ends with the
contradiction (indicated by $\bot$) which arises from $0 < 0$.

\subsection{Choice}

The presence of disjunctions in the assertion being checked can result
in the proof diverging down two different paths.  The illustrates a
minimal example:

\begin{lstlisting}[language=WyAL]
assert:
   forall(int x):
      if:
         (x == 0) || (x > 0)
      then:
         x >= 0
\end{lstlisting}

The disjunction \clstinline{(x == 0) \|\| (x > 0)} generates two cases
which need to be considered separately.  The proof for this assertion
is given in Figure~\ref{p:choice}.  We can see that the proof has two
nested boxes representing the two branches of the proof.  New
information can only be derived in a branch from facts already known
in that branch and its ancestors.  

The first branch of the proof in Figure~\ref{p:choice} makes use of
the {\em congruence} rule over atoms $x_1 == 0$ and $x_1 < 0$ to give
$0 < 0$.  In essence, this rule substitutes $x_1$ for $0$ in the atom
$x_1 < 0$.

\begin{figure}[!t]
\begin{wyproof}
(1) & \exists(int\;x).((x == 0\lor x > 0)\land x < 0) &\\
&&\\
\hline
\hline
&&\\
(2) & (x == 0\lor x > 0)\land x < 0 & (\exists\textrm{-elimination}, 1)\\
(3) &  (x_1 == 0\lor x_1 > 0) & (\land\textrm{-elimination}, 2)\\
(4) &  x_1 < 0 & (\land\textrm{-elimination}, 2)\\
&&\\
\multicolumn{3}{c}{
  \begin{wyproof}
    (5) & x_1 == 0 & (\lor\textrm{-elimination}, 2)\\
    (6) & x_1 < x_1 & (\textrm{congruence}, 4 + 5)\\
    (7) & \bot & (\textrm{simplification}, 6)\\
  \end{wyproof}
}\\
\multicolumn{3}{c}{
  \begin{wyproof}
    (8) & x_1 > 0 & (\lor\textrm{-elimination}, 2)\\
    (9) & 0 < 0 & (\le\!\textrm{-closure}, 4 + 8)\\
    (10) & \bot & (\textrm{simplification}, 5)\\
  \end{wyproof}
}\\
\end{wyproof}
\caption{Illustrates a proof which two branches arising from a disjunction.}
\label{p:choice}
\end{figure}

\subsection{Counterexamples}

Whilst the assertions we have looked at so far have all been correct,
this is not necessarily the case.  For example, consider the following
assertion:

\begin{lstlisting}[language=WyAL]
assert:
   forall(int x):
      if:
          x >= 0
      then:
          x > 1
\end{lstlisting}

This assert does not hold and, hence, we cannot construct a proof
which yields a contradiction.  In other words, there is a {\em model}
in which this assertion evaluates to \clstinline{false}, and such
models are referred to as {\em counterexamples}.  A model is simply an
assignment of variables and, for example, one counterexample for this
assertion is ${\tt\{x\mapsto 0\}}$.  Note that there may be many
different counterexamples for a given assertion (even an infinite
number).  For example, another counterexample for the above assertion
is ${\tt\{x\mapsto 1\}}$.

\section{Proof Rules}

\subsection{Axioms}
\subsection{Case Analysis}
\subsection{Congruence}
\subsection{Arithmetic}
\subsection{Quantifier Instantiation}

\section{Proof Rewriting}

\section{Notes}
\begin{itemize}
\item {\bf Proof}.  Rules.  Choices.  By contradiction.
\item {\bf Rules}.  Difference kinds of rules.  Simplification.  Case analysis.  Axioms.  Inference.  Quantifier Instantiation.
\item {\bf Rewriting History}.  Proof Rewriting, etc.
\end{itemize}