\chapter{Statements}

The execution of a Whiley program is controlled by \gls{statement}s, which cause effects on the environment.  However, statements in Whiley do not produce values.  \Gls{compound_statement} statements may contain other statements.

\section{Blocks}
\label{c_stmts_blocks}

A \gls{statement_block} is a sequence of zero or more consecutive statements which have the same indentation.  Statement blocks are used to group statements together when constructing \gls{compound_statement}s.  For example:
\begin{lstlisting}
function sum([int] items) => int:
    // outer block begins
    int r = 0
    int i = 0
    while i < |items|:
        // inner block begins
        r = r + items[i]
        i = i + 1
        // inner block ends
    //
    return r
    // outer block ends
\end{lstlisting}
The above example contains two statement blocks, one nested inside the other.  The outer block demarcates the body of the \lstinline{sum()} function, whilst the inner block demarcates the body of the \lstinline{while} statement.

% =======================================================================
% AssertStatement
% =======================================================================

\section{Assert Statement}

Represents an {\em assert statement} of the form ``\lstinline{assert e}'', where \lstinline{e} is a \gls{boolean_expression}.  A \gls{fault} will be raised at runtime if the asserted expression evaluates to \lstinline{false}; otherwise, execution will proceed normally.  At verification time, the verifier is forced to ensure that the asserted expression is true for all possible execution paths.  This allows the programmer to specify and check something he/she believes to be true at a given point in the program.

\begin{syntax}
  \verb+AssertStmt+ & $::=$ & \token{assert}\ \verb+Expr+\\
\end{syntax}

\paragraph{Example.} The following illustrates an \lstinline{assert} statement:
\begin{lstlisting}
function abs(int x) => int:
    if x < 0:
        x = -x
    assert x >= 0
    return x
\end{lstlisting}
Here, an assertion is used to check that the value being returned by the \lstinline{abs()} is non-negative.  Since this is a true statement of the function, this statement will never raise a fault.

% =======================================================================
% Assignment Statement
% =======================================================================

\section{Assignment Statement}

As {\em assignment statement} is of the form \lstinline{leftHandSide = rightHandSide}.  Here, the \lstinline{rightHandSide} is any expression, whilst the \lstinline{leftHandSide} must be an \lstinline{LVal} --- that is, an expression permitted on the left-hand side of an assignment.  At runtime, the value generated by evaluating the right-hand side must be a subtype (\S\ref{c_types_subtyping}) of the left-hand side.

\begin{syntax}
  \verb+AssignStmt+ & $::=$ & \verb+LVal+\ \token{=}\ \verb+Expr+\\
\end{syntax}


\paragraph{Example.} The following illustrates different possible assignment statements:
\begin{lstlisting}
x = y       // variable assignment
x.f = y     // field assignment
x[i] = y    // list assignment
x[i].f = y  // compound assignment
\end{lstlisting}
The last assignment here illustrates that the left-hand side of an assignment can be arbitrarily complex, involving nested assignments into lists and records.

% =======================================================================
% Assume Statement
% =======================================================================

\section{Assume Statement}

An {\em assume statement} is of the form ``\lstinline{assume e}'', where \lstinline{e} is a \gls{boolean_expression}.  A \gls{fault} will be raised at runtime if the assumed expression evaluates to \lstinline{false}; otherwise, execution will proceed normally.  At verification time, the verifier will automatically assume that the given expression holds.  Thus, \lstinline{assume} statements provide a way for the programmer to override the verifier.  This is useful where the verifier is unable to establish something that the programmer knows to be true.  Care must be taken to ensure that the assumed expression really does hold.

\begin{syntax}
  \verb+AssumeStmt+ & $::=$ & \token{assume}\ \verb+Expr+\\
\end{syntax}

\paragraph{Example.} The following illustrates an \lstinline{assume} statement:

\begin{lstlisting}
function abs(int x) => (int y) ensures y >= 0:
    //
    assume x >= 0
    return x
\end{lstlisting}
Here, the programmer has used an assumption to ensure this function passes verification.  This would not appear to be safe in this case, and may lead to a fault at runtime.

% =======================================================================
% Break Statement
% =======================================================================

\section{Break Statement}
\label{c_stmts_break}
A {\em break statement} transfers control out of the enclosing loop (i.e. \lstinline{do}, \lstinline{for}, \lstinline{while}).  It is a compile-time error if no such enclosing loop exists.

\begin{syntax}
  \verb+BreakStmt+ & $::=$ & \token{break}\\
\end{syntax}

\paragraph{Example.} The following illustrates a \lstinline{break} statement:

\begin{lstlisting}
// Remove lowest element holding x from xs
function remove([int] xs, int x) => [int]:
    int i = 0
    while i < |xs|:
        if xs[i] == x:
           break
        else:
           i = i + 1
    return xs[0..i] ++ xs[i+1..]
\end{lstlisting}
Here, we see a \lstinline{break} statement being used to exit a \lstinline{while} loop when the first element matching parameter \lstinline{x} is found.  

\paragraph{Notes.} Unlike many other programming languages (e.g. Java), \lstinline{break} statements cannot be used to transfer control out of a \lstinline{switch} statement (\S\ref{c_stmts_switch}).  This is because \lstinline{switch} statements have {\em explicit}, rather than {\em implicit}, fall-through.

% =======================================================================
% Continue Statement
% =======================================================================

\section{Continue Statement}
\label{c_stmts_continue}
A {\em continue statement} can be used either to transfer control to the next iteration of the enclosing loop (i.e. \lstinline{do}, \lstinline{for}, \lstinline{while}), or to transfer control to the next case of the enclosing \lstinline{switch} statement.

\begin{syntax}
  \verb+ContinueStmt+ & $::=$ & \token{continue}\\
\end{syntax}

\paragraph{Example.} The following illustrates a \lstinline{continue} statement:

\begin{lstlisting}
function sumNonNegative([int] xs) => int:
    int i = 0
    int r = 0
    for i in 0 .. |xs|:
        if xs[i] < 0:
            continue
        r = r + xs[i]
    return r
\end{lstlisting}
Here, a \lstinline{continue} statement is used to ensure the negative numbers are not included in the result of the function.

\paragraph{Notes.} Unlike many other programming languages (e.g. Java), \lstinline{continue} statements are used to transfer control to the next case of a \lstinline{switch} statement (\S\ref{c_stmts_switch}).  This is because \lstinline{switch} statements have {\em explicit}, rather than {\em implicit}, fall-through.

% =======================================================================
% Debug Statement
% =======================================================================

\section{Debug Statement}
A {\em debug statement} outputs the result of evaluating its expression to the {\em debug stream}.  Debug statements are intended to be used purely for debugging, particularly from within (pure) functions.  The debug stream is an imaginary output stream which does not exist in the true semantic of the language.  Instead, from an operational semantics perspective, the debug statement is equivalent to the skip statement (\S\ref{c_stmts_skip}).

\begin{syntax}
  \verb+DebugStmt+ & $::=$ & \token{debug}\ \verb+Expr+\\
\end{syntax}

\paragraph{Example.} The following illustrates a \lstinline{debug} statement:

\begin{lstlisting}
function f(int x) => int:
    debug "f(" ++ x ++ ") called"
    if x == 1 || x == 0:
       return x
    else:
       return f(x-1) + f(x-2)
\end{lstlisting}
Here, we see a recursive implementation of the well-known {\em fibonacci} sequence.  A \lstinline{debug} statement is being used to investigate the parameter values passed to the function.

% =======================================================================
% Do/While Statement
% =======================================================================

\section{Do/While Statement}
\label{c_stmts_do_while}
A do-while statement repeatedly executes a statement block until an expression (the condition) evaluates to \lstinline{false}.  Optional \lstinline{where} clause(s) are permitted which, together, are commonly referred to as the \gls{loop_invariant}.  

\begin{syntax}
  \verb+DoWhileStmt+$^\ell$ & $::=$ & \token{do}\ \token{:}
  \verb+Block+$^\gamma$\ \token{while}\ \verb+Expr+\ \big(\
  \token{where}\ \verb+Expr+\ \big)$^*$\\
&&\\
\multicolumn{3}{r}{(where $\ell < \gamma$)}\\
\end{syntax}

\paragraph{Example.} The following illustrates an do-while statement:

\begin{lstlisting}
function sum([int] xs) => int
// Input must not be empty list
requires |xs| > 0:
  //
  int r = 0
  int i = 0
  do:
    r = r + xs[i]
    i = i + 1
  while i < |xs| where i >= 0:
  //
  return r
\end{lstlisting}
Here, we see a simple do-while statement which sums the elements of variable \lstinline{xs}, storing the result in variable \lstinline{r}.  A loop invariant is given which establishes that variable \lstinline{i} is non-negative.

\paragraph{Notes.}   When multiple \lstinline{where} clauses are given, these are combined using a conjunction to form the loop invariant.  The combined invariant must hold on entry to the loop and after each iteration.  Thus, when the condition evaluates to \lstinline{false}, the loop invariant is guaranteed to hold.  However, the loop invariant need not hold when the loop is exited using a \lstinline{break} (\S\ref{c_stmts_break}) statement.

% =======================================================================
% For Statement
% =======================================================================

\section{For Statement}
\label{c_stmts_for}
A {\em for statement} iterates over all elements in a collection obtained from evaluating the {\em source expression}.  Optional \lstinline{where} clause(s) are permitted which, together, are commonly referred to as the \gls{loop_invariant}.  

\begin{syntax}
  \verb+ForStmt+$^\ell$ & $::=$ & \token{for}\ \verb+VarPattern+\
  \token{in}\ \verb+Expr+\ \big(\ \token{where}\ \verb+Expr+\
  \big)$^*$\ \token{:} \verb+Block+$^\gamma$\\
&&\\
\multicolumn{3}{r}{(where $\ell < \gamma$)}\\
\end{syntax}

\paragraph{Example.} The following illustrates a \lstinline{for} statement:

\begin{lstlisting}
function max([int] items) => int
// Input list cannot be empty
requires |items| > 0:
   //
   int r = items[0]
   
   for i,v in items:
        r = Math.max(r,v)
   
   return v
\end{lstlisting}
Here, we see a simple \lstinline{for} loop which iterates over all elements of the list \lstinline{items}.  At each iteration, variable \lstinline{i} holds the index whilst \lstinline{v} contains the element at that index (i.e. \lstinline{v == items[i]}).

\paragraph{Notes.}   When multiple \lstinline{where} clauses are given, these are combined using a conjunction to form the loop invariant.  The combined invariant must hold on entry to the loop and after each iteration.  Thus, when the condition evaluates to \lstinline{false}, the loop invariant is guaranteed to hold.  However, the loop invariant need not hold when the loop is exited using a \lstinline{break} (\S\ref{c_stmts_break}) statement.

% =======================================================================
% If Statement
% =======================================================================

\section{If Statement}
\label{c_stmts_if}
An \lstinline{if} statement conditionally executes a \gls{statement_block} based on the outcome of one or more expressions.  Chaining of \lstinline{if} statements is permitted, and an optional \lstinline{else} branch may be given.  The expression(s) are referred to as {\em conditions} and must be \gls{boolean_expression}s.  The first block is referred to as the {\em true branch}, whilst the optional \lstinline{else} block is referred to as the {\em false branch}.

\begin{syntax}
  \verb+IfStmt+$^\ell$ & $::=$ & \token{if}\ \verb+Expr+\ \token{:}
  \verb+Block+$^\gamma$\ \big( \token{else} \token{if}\ \verb+Expr+\ \token{:}
  \verb+Block+$^{\omega_i}$\ \big)$^*$ \\
&& \big[ \token{else} \token{:} \verb+Block+$^\phi$\ \big]\\
&&\\
\multicolumn{3}{r}{(where $\ell < \gamma$ and $\forall i.\ell <
  \omega_i$ and $\ell < \phi$)}\\
\end{syntax}

\paragraph{Example.} The following illustrates an \lstinline{if} statement:

\begin{lstlisting}
function max(int x, int y) => int:
    if(x > y):
        return x
    else if(x == y):
        return 0
    else:
        return y
\end{lstlisting}
Here, we see an \lstinline{if} statement with two conditional outcomes
and one default outcome.

% =======================================================================
% While Statement
% =======================================================================

\section{While Statement}
\label{c_stmts_while}
A while statement repeatedly executes a statement block until an expression (the condition) evaluates to \lstinline{false}.  Optional \lstinline{where} clause(s) are permitted which, together, are commonly referred to as the \gls{loop_invariant}.  

\begin{syntax}
  \verb+WhileStmt+$^\ell$ & $::=$ & \token{while}\ \verb+Expr+\ \big(\
  \token{where}\ \verb+Expr+\ \big)$^*$\ \token{:}\ \verb+Block+$^\gamma$\ \\
&&\\
\multicolumn{3}{r}{(where $\ell < \gamma$)}\\
\end{syntax}

\paragraph{Example.} The following illustrates an \lstinline{while} statement:

\begin{lstlisting}
function sum([int] xs) => int:
  int r = 0
  int i = 0
  while i < |xs| where i >= 0:
    r = r + xs[i]
    i = i + 1
  return r
\end{lstlisting}
Here, we see a simple \lstinline{while} statement which sums the elements of variable \lstinline{xs}, storing the result in variable \lstinline{r}.  A loop invariant is given which establishes that variable \lstinline{i} is non-negative.

\paragraph{Notes.}   When multiple \lstinline{where} clauses are given, these are combined using a conjunction to form the loop invariant.  The combined invariant must hold on entry to the loop and after each iteration.  Thus, when the condition evaluates to \lstinline{false}, the loop invariant is guaranteed to hold.  However, the loop invariant need not hold when the loop is exited using a \lstinline{break} (\S\ref{c_stmts_break}) statement.

% =======================================================================
% ReturnStatement
% =======================================================================

\section{Return Statement}
\label{c_stmts_return}
A {\em return statement} has an optional expression referred to as the {\em return value}.  At runtime, this statement returns control to the caller of the enclosing function or method.  At verification time, the verifier will ensure the returned value meets the \gls{postcondition} of the enclosing function or method.

\begin{syntax}
  \verb+ReturnStmt+ & $::=$ & \token{return}\ \big[\ \verb+Expr+\
  \big]\\
\end{syntax}

\paragraph{Example.} The following illustrates a \lstinline{return} statement:

\begin{lstlisting}
function f(int x) => int:
    return x + 1
\end{lstlisting}
Here, we see a simple simple function which returns the increment of its parameter \lstinline{x} using a \lstinline{return} statement.


\paragraph{Notes.} The returned expression (if there is one) must begin on the same line as the statement itself.

% =======================================================================
% Skip Statement
% =======================================================================

\section{Skip Statement}
\label{c_stmts_skip}
A {\em skip statement} is a no-operation and has no effect on the environment.  This statement can be useful for representing empty statement blocks (\S\ref{c_stmts_blocks}).

\begin{syntax}
  \verb+SkipStmt+ & $::=$ & \token{skip}\\
\end{syntax}

\paragraph{Example.} The following illustrates a \lstinline{skip} statement:

\begin{lstlisting}
function abs(int x) => (int y)
// Return value cannot be negative
ensures y >= 0:
    //
    if x >= 0:
        skip
    else:
        x = -x
    //
    return x
\end{lstlisting}
Here, we see a \lstinline{skip} statement being used to represent an empty statement block.  

% =======================================================================
% Switch Statement
% =======================================================================

\section{Switch Statement}
\label{c_stmts_switch}
A {\em switch statement} transfers control to one of several statement blocks, referred to as {\em switch cases}, depending on the value obtained from evaluating a given expresion.  Each case is associated with one or more values which are used to match against.  If no match is made, control either falls through to the next statement following the \lstinline{switch} or is transferred to a \lstinline{default} block if one is given.

\begin{syntax}
  \verb+SwitchStmt+$^\ell$ & $::=$ & \token{switch}\ \verb+Expr+\ \token{:}\ \big(\ \verb+CaseBlock+$^\gamma$\ $|$\ \verb+DefaultBlock+$^\gamma$\ \big)\ $^+$\\
  &&\\
  \verb+CaseBlock+$^\ell$ & $::=$ & \token{case} \verb+ConstantExpr+\ \big(\ \token{,}\ \verb+ConstantExpr+\ \big)$^*$\ \token{:}\ \verb+Block+$^\gamma$\\
  &&\\
  \verb+DefaultBlock+$^\ell$ & $::=$ & \token{default}\ \token{:}\ \verb+Block+$^\gamma$\\
&&\\
\multicolumn{3}{r}{(where $\ell < \gamma$)}\\
\end{syntax}

\paragraph{Example.} The following illustrates a \lstinline{switch} statement:

\begin{lstlisting}
function toDescriptorString(JvmType.Primitive t) => string:
    switch t:
        case JvmType.Boolean:
            return "Z"
        case JvmType.Byte:
            return "B"
        case JvmType.Char:
            return "C"
        case JvmType.Short:
            return "S"
        case JvmType.Int:
            return "I"
        case JvmType.Long:
            return "J"
        case JvmType.Float:
            return "F"
        default:
            return "D"
\end{lstlisting}
Here, we see a simple \lstinline{switch} statement which choose between a number of possible values of type \lstinline{JvmType.Primitive}.  A \lstinline{default} case is given which catches the only remaining case (i.e. representing the value \lstinline{JvmType.Double}).

% =======================================================================
% ThrowStatement
% =======================================================================

\section{Throw Statement}
\label{c_stmts_throw}
A {\em throw statement} causes an exception to thrown which, if not caught locally, causes an \gls{abrupt_termination} of the current function or method.  Functions or methods which may terminate abruptly must declare appropriate an throws clause (\S\ref{c_source_files_function_decl},\S\ref{c_source_files_method_decl}) which contains al potentially thrown exceptions.

\begin{syntax}
  \verb+ThrowStmt+ & $::=$ & \token{throw}\ \verb+Expr+\\
\end{syntax}

\paragraph{Example.} The following illustrates a \lstinline{throw} statement:

\begin{lstlisting}
function parseInt(int pos, string input) => (int,int)
// Throws a syntax error if the string is malformed
throws SyntaxError:
    //
    int start = pos
    // check for negative input
    if pos < |input| && input[pos] == '-':
        pos = pos + 1
    // match remainder
    while pos < |input| && Char.isDigit(input[pos]):
        pos = pos + 1
    // check for error
    if pos == start:
        throw SyntaxError("Missing number",start,pos)
    // done
    return Int.parse(input[start..pos]),pos
\end{lstlisting}
Here, we see a function which parses a string into an integer.  The function declares that a \lstinline{SyntaxError} may be thrown.  This is required for two reasons:  firstly, the input contains no digits then an \lstinline{SyntaxError} is thrown by this function.  Additionally, the function \lstinline{Int.parse()} is declared to throw a \lstinline{SyntaxError} and, since it is not caught, this declaration must be propagated.

% =======================================================================
% Try/Catch Block
% =======================================================================

\section{Try Statement}
\label{c_stmts_try_catch}
A {\em try} statement demarcates a \gls{statement_block} to be executed in the context of one or more {\em exception handlers}.  If an uncaught exception is raised within the block which matches one (or more) of the exception handlers, then control is transferred directly to that handler.  Exception handlers are matched against raised exceptions in the order of declaration.

\begin{syntax}
  \verb+TryStmt+$^\ell$ & $::=$  & \token{try}\ \token{:}\ \verb+Block+$^\gamma$\ \big(\ \token{catch} \token{(}\ \verb+Type+\ \verb+Ident+\ \token{)} \token{:}\ \verb+Block+$^{\omega_i}$\ \big)$^+$\\
&&\\
\multicolumn{3}{r}{(where $\ell < \gamma$ and $\forall i.\ell < \omega_i$ and $\ell < \phi$)}\\
\end{syntax}

\paragraph{Example.}  The following illustrates a \lstinline{try} statement:

\begin{lstlisting}
function parse(string input) => int|string|null
// Input cannot be empty
requires |input| > 0:
    //
    try:
        if Char.isDigit(input[0]):
            // must be integer
            return Int.parse(input)
        else:
            // must be string
            return input
    catch(SyntaxError ex):
        // We can get here from Int.parse()
        return null
\end{lstlisting}
Here, we see a function which parses a string as an integer (if it begins with a digit) or returns the input string (otherwise).  The function \lstinline{Int.parse(string)} throws a \lstinline{SyntaxError} in the case that its parameter is not well-formed.  A \lstinline{try} statement is used to catch this and return \lstinline{null} in such case.

\paragraph{Notes.} Exceptions in Whiley differ from those found in other languages (e.g. Java) as they do not include runtime errors (e.g. divide-by-zero, out-of-bounds access, out-of-memory, stack-overflow, etc),  Instead, all exceptions are explicitly thrown using a \lstinline{throw} statement.  In contrast, runtime errors correspond to \gls{fault}s in Whiley, and are thrown implicitly when an unrecoverable error occurs.

% =======================================================================
% Variable Declarations
% =======================================================================

\section{Variable Declaration Statement}
\label{c_stmts_var_decl}
A \gls{variable_declaration} statement has an optional expression assignment referred to as a \gls{variable_initialiser}.  If an initialiser is given, this will be evaluated and assigned to the declared variables when the declaration is executed.  

\begin{syntax}
  \verb+VarDecl+ & $::=$ & \verb+TypePattern+\ \big[\
  \token{=}\ \verb+Expr+\ \big]\\
\end{syntax}

\paragraph{Example.} Some example variable declarations are:
\begin{lstlisting}
int x
int y = 1
int z = x + y
int a, int b = x,y
\end{lstlisting}
Here we see four variable declarations.  The first has no initialiser, whilst the remainder have initialisers.  The final declaration illustrates a more complex use of type patterns where two variables of type \lstinline{int} are initialised from a tuple expression
