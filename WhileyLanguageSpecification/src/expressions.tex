\chapter{Expressions}
The majority of work performed by a Whiley program is through the execution of \glspl{expression}.  Every expression produces a \gls{value} and may have additional side effects.

\section{Evaluation Order}

% =======================================================================
% Multi Expression
% =======================================================================

\section{Multi Expressions}
\label{c_expr_tuple}
A multi-expression is an expression composed of two or more unit expressions and which returns a tuple value (\S\ref{c_types_tuple}).  The operands of a multi-expression are evaluated in a strict left-to-right order.

\begin{syntax}
  \verb+TupleExpr+ & $::=$ & \verb+UnitExpr+ \big(\ \token{,}\ \verb+UnitExpr+\ \big)$^+$ \\
\end{syntax}

\paragraph{Example.}  The following example illustrates the use of a multi-expression:

\begin{lstlisting}
function scale(real x, real y, real p) => (real,real):
    return (x*p), (y*p)
\end{lstlisting}

This function accepts three \lstinline{real} values and returns two.  In the body, the \lstinline{return} statement contains a multi-expression which produces a tuple composed of two \lstinline{real} values.

% =======================================================================
% Unit Expression
% =======================================================================

\section{Unit Expressions}
\label{c_expr_unit}

A unit expression is an expression which returns exactly one value.  There is a large range of possible unit expressions, including comparators, arithmetic operators, logical operators, etc.

\begin{syntax}
  \verb+UnitExpr+ & $::=$ & \verb+LogicalExpr+\\
                  &  $|$  & \verb+BitwiseExpr+\\
                  &  $|$  & \verb+ConditionExpr+\\
                  &  $|$  & \verb+QuantifierExpr+\\
                  &  $|$  & \verb+AppendExpr+\\
                  &  $|$  & \verb+RangeExpr+\\
                  &  $|$  & \verb+ShiftExpr+\\
                  &  $|$  & \verb+AdditiveExpr+\\
                  &  $|$  & \verb+MultiplicativeExpr+\\
                  &  $|$  & \verb+AccessExpr+\\
                  &  $|$  & \verb+UnaryExpr+\\
                  &  $|$  & \verb+LambdaExpr+\\
                  &  $|$  & \verb+TermExpr+\\
                
\end{syntax}

% =======================================================================
% Quantifier Expressions
% =======================================================================

\section{Quantifier Expressions}
\label{c_expr_quantifier}

\begin{syntax}
\verb+QuantExpr+ & $::=$ & \big(\ \token{no} $|$ \token{some} $|$
\token{all}\ \big)\ \token{\{}\\
&&\ \verb+Ident+ \token{in} \verb+Expr+ \big( \token{,}\ \verb+Ident+\
\token{in}\ \verb+Expr+\ \big)$^+$\ \token{|}\ \verb+LogicalExpr+\\
&& \token{\}}\\
\end{syntax}

\paragraph{Description.}

\paragraph{Examples.}

\paragraph{Notes.} 

% =======================================================================
% Binary Expressions
% =======================================================================

\section{Binary Expressions}
\label{c_expr_binary}

% =======================================================================
% Logical Expressions
% =======================================================================

\subsection{Logical Expressions}
\label{c_expr_logical}

A logical expression operates on values of \lstinline{bool} type (\S\ref{c_types_bool}) to produce another \lstinline{bool} value.  The {\em if-and-only-if (iff)} operator, \lstinline{<==>}, returns \lstinline{true} if either both operands are \lstinline{true} or both are \lstinline{false}.  The {\em implication} operator, \lstinline{==>}, returns \lstinline{true} if either the left operand is \lstinline{false}, or both operands are \lstinline{true}.  The {\em logical OR} operator returns \lstinline{true} if either operand is \lstinline{true}, whilst the {\em logical AND} operator returns \lstinline{true} if both operands are \lstinline{true}.

\begin{syntax}
  \verb+LogicalExpr+ & $::=$ & \verb+LogicalOrExpr+ \big[ \token{<==>} \verb+LogicalExpr+\ \big]\\
                     &  $|$  & \verb+LogicalOrExpr+ \big[ \token{==>} \verb+LogicalExpr+\ \big]\\
  &&\\
  \verb+LogicalOrExpr+ & $::=$ & \verb+LogicalAndExpr+ \\
                           & $|$ & \verb+LogicalOrExpr+ \token{||} \verb+LogicalAndExpr+\\
  &&\\
  \verb+LogicalAndExpr+ & $::=$ & \verb+BitwiseExpr+ \\
                            & $|$ & \verb+LogicalAndExpr+ \token{\&\&} \verb+BitwiseExpr+\\
\end{syntax}

\paragraph{Example.}  The following examples illustrate some of the logical operators:

\begin{lstlisting}
function implies(bool x, bool y) => bool:
    return !x || y

function iff(bool x, bool y) => bool:
    return implies(x,y) && implies(y,x)
\end{lstlisting}

The function \lstinline{implies()} implements the well-known equivalence between implication and logical OR.  The function \lstinline{iff()} implements the well-known equivalence between implication and iff.

% =======================================================================
% Relational Expressions
% =======================================================================

\subsection{Relational Expressions}
\label{c_expr_relational}

A relational expression compares two (or more) values together producing a value of \lstinline{bool} type.  Such expressions determine whether a given relationship exists between values. 

% =======================================================================
% Condition Expressions
% =======================================================================

\subsubsection{Equality Expressions}
\label{c_expr_equality}
The {\em equality comparator}, \lstinline{==}, tests whether two values are equal.  Likewise, the {\em inequality comparator}, \lstinline{==}, tests whether two values are {\em not} equal.

\begin{syntax}
  \verb+ConditionExpr+ & $::=$ &\\
  & $|$ & \verb+AppendExpr+ \token{==} \verb+AppendExpr+\\
  & $|$ & \verb+AppendExpr+ \token{!=} \verb+AppendExpr+\\
\end{syntax}

\paragraph{Example.}

The following example illustrates an equality expression:

\begin{lstlisting}
function contains([int] items, int item) => bool:
    //
    for i in items:
        if i == item:
            return true
    return false
\end{lstlisting}

This function checks whether a given integer is contained in a list of integers.  This is done by iterating each element of the list and comparing it against the given item.


\subsubsection{Inequality Expressions}
\label{c_expr_inequality}
Inequality expressions are either {\em strict} (where only inequality is tested)  or {\em non-strict} (where both equality and inequality are tested).  The {\em less-than comparator}, \lstinline{<}, and {\em greater-than comparator}, \lstinline{>}, are strict.  Conversely, the {\em less-than-or-equal comparator}, \lstinline{<=}, and {\em greater-than-or-equal comparator}, \lstinline{>}, are non-strict.

\begin{syntax}
  \verb+ConditionExpr+ & $::=$ &\\
  & $|$ & \verb+AppendExpr+ \token{<} \verb+AppendExpr+\\
  & $|$ & \verb+AppendExpr+ \token{<=} \verb+AppendExpr+\\
  & $|$ & \verb+AppendExpr+ \token{=>} \verb+AppendExpr+\\
  & $|$ & \verb+AppendExpr+ \token{>} \verb+AppendExpr+\\
\end{syntax}

\paragraph{Example.} The following example illustrates the strict inequality comparators:

\begin{lstlisting}
function compare(int x, int y) => int:
    if x < y:
        return -1
    else if x > y:
        return 1
    else:
        return 0
\end{lstlisting}

This function compares two integer arguments and returns the ``sign'' of their comparison.  The strict inequality comparators are used so the case where \lstinline{x == y} can be distinguished.

\subsubsection{Subset Expressions}
\label{c_expr_relational}
Subset expressions are either {\em strict} (where only inequality is tested)  or {\em non-strict} (where both equality and inequality are tested).  The {\em subset comparator}, ${\tt\subset}$, is strict.  Conversely, the {\em subset-or-equal comparator}, ${\tt\subseteq}$, is non-strict

\begin{syntax}
  \verb+ConditionExpr+ & $::=$ &\\
  & $|$ & \verb+AppendExpr+ \token{$\subset$} \verb+AppendExpr+\\
  & $|$ & \verb+AppendExpr+ \token{$\subseteq$} \verb+AppendExpr+\\
\end{syntax}

\paragraph{Example.} The following example illustrates the strict comparator:

\begin{lstlisting}
function compare({int} xs, {int} ys) => int:
    if xs $\subset$ ys:
        return -1
    else if ys $\subset$ xs:
        return 2
    else if xs == ys:
        return 1
    else:
        return 0
\end{lstlisting}

This function compares two integer sets and returns the ``sign'' of their comparison.  The non-strict inequality comparators are used so the cases where \lstinline{xs == ys} and \lstinline{xs != ys} can be distinguished.

\paragraph{Notes.}  At the time of writing there is no keyword or non-unicode operator for expressing these comparators.

\subsubsection{Element-Of Expression}
\label{c_expr_relational}
An element-of expression determines whether one value is contained within another value of collection type (\S\ref{c_types_collection}) and produces a value of \lstinline{bool} type.  Specifically, if the element is contained then the result is \lstinline{true}, otherwise it is \lstinline{false}.

\begin{syntax}
  \verb+ConditionExpr+ & $::=$ &\\
  & $|$ & \verb+AppendExpr+ \token{in} \verb+AppendExpr+\\
  & $|$ & \verb+AppendExpr+ \token{$\in$} \verb+AppendExpr+\\
\end{syntax}

\paragraph{Example.}  The following illustrates the element-of operator.

\begin{lstlisting}
function containsOne({int} xs, {int} ys):
    for x in xs:
        if x in ys:
            return true
    return false
\end{lstlisting}
This function accepts two integer sets and checks whether any element of the first parameter is in the second.


% =======================================================================
% Bitwise Expressions
% =======================================================================

\subsection{Bitwise Expressions}
\label{c_expr_bitwise}
A bitwise expression operates on values of \lstinline{byte} type (\S\ref{c_types_byte}).  The {\em bitwise OR} operator, \lstinline{|}, performs a logical OR between the respective bits of each operand, and produces a \lstinline{byte}.  The {\em bitwise AND} operator, \lstinline{&}, performs a logical AND between the respective bits of each operand, and produces a \lstinline{byte}.   The {\em bitwise exclusive-OR} operator, \lstinline{^}, performs a logical exclusive-OR between the respective bits of each operand, and produces a \lstinline{byte}.

\begin{syntax}
  \verb+BitwiseExpr+ & $::=$ & \verb+BitwiseOrExpr+ \\
  &&\\
  \verb+BitwiseOrExpr+ & $::=$ & \verb+BitwiseXorExpr+ \\
                           & $|$ & \verb+BitwiseOrExpr+ \token{|} \verb+BitwiseXorExpr+\\
  &&\\
  \verb+BitwiseXorExpr+ & $::=$ & \verb+BitwiseAndExpr+ \\
                            & $|$ & \verb+BitwiseXorExpr+ \token{\^} \verb+BitwiseAndExpr+\\
  &&\\
  \verb+BitwiseAndExpr+ & $::=$ & \verb+ConditionExpr+ \\
                            & $|$ & \verb+BitwiseAndExpr+ \token{\&\&} \verb+ConditionExpr+\\

\end{syntax}

\paragraph{Example.}  The following example illustrates the bitwise OR operator:

\begin{lstlisting}
function toUnsignedByte(u8 v) => byte:
    //
    byte mask = 00000001b
    byte r = 0b
    for i in 0..8:
        if (v % 2) == 1:
            r = r | mask
        v = v / 2
        mask = mask << 1
    return r  
\end{lstlisting}

This function converts an unsigned integer in the range \lstinline{0} ... \lstinline{255} to a \lstinline{byte}.  The bitwise OR operator is used to construct the resulting \lstinline{byte} by setting individual bits via the \lstinline{mask}.  This example also illustrates the left-shift operator (\S\ref{c_expr_shift}).


\subsection{Set Expressions}
\label{c_expr_set}

Set union, intersection and difference.

% =======================================================================
% Append Expressions
% =======================================================================

\subsection{Append Expressions}
\label{c_expr_append}

An append expression accepts two lists arguments and produces a value of list type.  The append operator, \lstinline{++}, concatenates the argument lists together, producing a list constructed from those elements of the first argument (in order0 followed by those of the second argument (in order).

\begin{syntax}
  \verb+AppendExpr+ & $::=$ & \verb+RangeExpr+\ \big(\ \token{++}\
  \verb+RangeExpr+\ \big)$^*$\\
\end{syntax}

\paragraph{Examples.} The following example illustrates the list append operator:
\begin{lstlisting}
function rangeOf(int start, int end) => [int]:
    [int] r = []
    int i = start
    while i < end:
        r = r ++ [i]
        i = i + 1
    return r
\end{lstlisting}

This function constructs a list containing the integer values from \lstinline{start} up to (but not including) \lstinline{end}.  The list append operator is used to construct the list, starting initially from the empty list.

% =======================================================================
% Range Expressions
% =======================================================================

\subsection{Range Expressions}
\label{c_expr_range}

A range expression accepts two integer arguments and produces a value of integer list type.  The {\em range operator} constructs the list of integer values from the first argument up to (but not including) the last.

\begin{syntax}
  \verb+RangeExpr+ & $::=$ & \verb+ShiftExpr+\ \big[\ \token{..}\ \verb+ShiftExpr+\ \big]\\
\end{syntax}

\paragraph{Examples.}  The following illustrates the range operator:

\begin{lstlisting}
function sum(int start, int end) => [int]:
    int r = 0
    for i in start .. end:
        r = r + i
    return r
\end{lstlisting}

This function sums the integers between \lstinline{start} and \lstinline{end}.  The range operator is used to construct the list to be iterated over.

\paragraph{Notes.}  If the start of a range expression is greater than its end, the empty list is returned.

% =======================================================================
% Shift Expressions
% =======================================================================

\subsection{Shift Expressions}
\label{c_expr_shift}

A shift expression accepts an argument of \lstinline{byte} type (left) and one of \lstinline{int} type (right) and produces a value of \lstinline{byte} type.  The {\em left shift operator}, \lstinline{<<}, shifts the bits of a \lstinline{byte} in an upwards direction, such that the most significant bit is discarded and the least significant bit assigned \lstinline{0}.  The {\em right shift operator}, \lstinline{>>}, shifts bits in a downwards direction, such that the least significant bit is discarded and the most significant bit assigned \lstinline{0}.  

\begin{syntax}
  \verb+ShiftExpr+ & $::=$ & \verb+AdditiveExpr+\ \big[\ \big(\
  \token{<<} $|$ \token{>>}\ \big)\ \verb+AdditiveExpr+ \big]
\end{syntax}

\paragraph{Examples.} The following illustrates the left shift operator:

\begin{lstlisting}
public function toUnsignedByte(u8 v) => byte:
    //
    byte mask = 00000001b
    byte r = 0b
    for i in 0..8:
        if (v % 2) == 1:
            r = r | mask
        v = v / 2
        mask = mask << 1
    return r
\end{lstlisting}

This function accepts an integer between \lstinline{0} and \lstinline{255} and converts this into an appropriate bit representation.  The left shift operator is used to maintain an internal mask for the bit currently being initialised.

% =======================================================================
% Addititve and Multiplicative Expressions
% =======================================================================

\subsection{Additive Expressions}
\label{c_expr_add}

An additive expression accepts two arguments of identical type (either \lstinline{int} or \lstinline{real}) and produces a result of matching type.  The {\em addition operator}, \lstinline{+}, adds both arguments together whilst the {\em subtraction operator}, \lstinline{-}, subtracts its right argument from its left argument.

\begin{syntax}
  \verb+AdditiveExpr+ & $::=$ & \verb+MultiplicativeExpr+ \big[\big(\ \token{+} $|$ \token{-}\ \big) \verb+AdditiveExpr+ \big]\\
\end{syntax}

\paragraph{Example.}  The following illustrates the additive operators:
\begin{lstlisting}
function diff(int a, int b) => int:
    return a - b
\end{lstlisting}
This function simply computes the difference between its two arguments using the subtraction operator.


\subsection{Multiplicative Expressions}
\label{c_expr_mul}

A multiplicative expression accepts two arguments of identical type (either \lstinline{int} or \lstinline{real}) and produces a result of matching type.  The {\em multiplication operator}, \lstinline{*}, multiplies both arguments together whilst the {\em division operator}, \lstinline{/}, divides its left argument by its right argument.  Finally, the {\em remainder operator} returns the remainder of its operands from an implied division.  

\begin{syntax}
  \verb+MultiplicativeExpr+ & $::=$ & \verb+AccessExpr+ \big[\big(\ \token{*} $|$ \token{/} $|$ \token{\%}\ \big) \verb+MultiplicativeExpr+ \big]\\
\end{syntax}

\paragraph{Example.} The following illustrates the remainder operator:

\begin{lstlisting}
function indexOf([int] xs, int i)
requires i >= 0 && |xs| > 0:
    //
    return xs[i % |xs|]
\end{lstlisting}
This function accepts a non-negative integer and uses this to index into a list.  To ensure the list access is within bounds, the remainder operator is used.  Furthermore, the function requires the list is non-empty to prevent a fault with the remainder operator.

\paragraph{Notes.}  For division, the right operator must be non-zero otherwise a \gls{fault} is raised, and likewise for remainder.  For integer division, the result is rounded towards zero.  For a remainder operation, the result may be negative (e.g. \lstinline{-4 % 3 == -1}).

% =======================================================================
% Access Expressions
% =======================================================================

\section{Access Expressions}
\label{c_expr_access}

\begin{syntax}
  \verb+AccessExpr+ & $::=$ & \verb+TermExpr+\\
   &  \big( &\token{[}\ \verb+AdditiveExpr+\ \token{]}\\
   & $|$ & \token{[}\ \verb+AdditiveExpr+\ \token{..}\ \verb+AdditiveExpr+\ \token{]}\\
   & $|$ & \token{.}\ \verb+Ident+\ \big[\ \token{(}\ \verb+ArgsList+\ \token{)}\ \big]\\
   & $|$ & \token{->}\ \verb+Ident+\ \big[\ \token{(}\ \verb+ArgsList+\ \token{)}\ \big]\\
   & \big)$^*$&\\
&&\\
\verb+ArgsList+ & $::=$ & \big[\ \verb+UnitExpr+\ \big(\ \token{,}\ \verb+UnitExpr+\ \big)$^*$\ \big]\\
\end{syntax}

\paragraph{Description.}

The {\em arrow operator} returns a field of the value referenced by the argument.

\paragraph{Examples.}

\paragraph{Notes.} The arrow operation ``\lstinline{e->f}'' is a short-hand notation for ``\lstinline{(*e).f}'' and can be used when \lstinline{e} has effective record type (\S\ref{c_types_effective_records}).

% =======================================================================
% Unary Expressions
% =======================================================================

\section{Unary Expressions}
\label{c_expr_term}

\begin{syntax}
  \verb+UnaryExpr+ & $::=$ & \verb+NegationExpr+\\
  & $|$ & \verb+LengthOfExpr+\\
  & $|$ & \verb+BracketedExpr+\\
  & $|$ & \verb+CastExpr+\\
  & $|$ & \verb+LogicalNotExpr+\\
  & $|$ & \verb+BitwiseCompExpr+\\
  & $|$ & \verb+NewExpr+\\
  & $|$ & \verb+DereferenceExpr+\\
\end{syntax}

% =======================================================================
% Negation Expression
% =======================================================================

\subsection{Negation Expression}
\label{c_expr_negation}

A negation expression accepts one argument of numeric type and produces a result of matching type.  Specifically, the {\em negation operator} mathematically negates the given value, which is always equivalent to subtracting the operand from zero.

\begin{syntax}
\verb+NegationExpr+ & $::=$ & \token{-}\ \verb+AccessExpr+\\
\end{syntax}

\paragraph{Example.} The following illustrates the negation operator:

\begin{lstlisting}
function negAccess(int i, [int] items) => int
requires -|items| <= i && i < |items|:
   //
   if i < 0:
       return -items[-(i+1)]
   else:
       return items[i]
\end{lstlisting}

\paragraph{Notes.}

% =======================================================================
% LengthOf Expression
% =======================================================================

\subsection{LengthOf Expression}
\label{c_expr_lengthof}

\begin{syntax}
\verb+LengthOfExpr+ & $::=$ & \token{|}\ \verb+AppendExpr+\ \token{|}\\
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Bracketed Expression
% =======================================================================

\subsection{Bracketed Expression}
\label{c_expr_bracketed}

\begin{syntax}
\verb+BracketedExpr+ & $::=$ & \token{(}\ \verb+MultiExpr+\ \token{)}\\
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Cast Expression
% =======================================================================

\subsection{Cast Expression}
\label{c_expr_cast}

\begin{syntax}
\verb+CastExpr+ & $::=$ & \token{(}\ \verb+DefiniteType+ \token{)}\ \verb+MultiExpr+\\
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Logical Not Expression
% =======================================================================

\subsection{Logical Not Expression}
\label{c_expr_logical_not}

\begin{syntax}
\verb+LogicalNotExpr+ & $::=$ & \token{!}\ \verb+ConditionExpr+\\
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Bitwise Complement Expression
% =======================================================================

\subsection{Bitwise Complement Expression}
\label{c_expr_bitwise_complement}

\begin{syntax}
\verb+BitwiseCompExpr+ & $::=$ & \token{~}\ \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% New Expression
% =======================================================================

\subsection{New Expression}
\label{c_expr_new}

\begin{syntax}
\verb+NewExpr+ & $::=$ & \token{new}\ \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Dereference Expressions
% =======================================================================

\subsection{Dereference Expression}
\label{c_expr_dereference}

A {\em dereference expression} accepts an argument of reference type and returns a value (or element) of the reference's target type.  The {\em dereference operator} returns the value referenced by the argument.  

\begin{syntax}
  \verb+DereferenceExpr+ & $::=$ & \token{*}\ \verb+TermExpr+\\\
  & $|$ & \verb+TermExpr+\ \token{->}\ \verb+Identifier+\\
\end{syntax}

\paragraph{Example.} The following illustrates the dereference operator:

\begin{lstlisting}
type LinkedList is null | &{LinkedList next, int data}

method length(LinkedList l) => int:
    //
    if l is null:
        return 0
    else:
        return 1 + length((*l).next)
\end{lstlisting}

This function traverses a linked list counting the number of links it contains.  The arrow operator is used to access the next link in the chain.

\paragraph{Notes.}

% =======================================================================
% Nary Expressions
% =======================================================================

\section{Constructor Expressions}
\label{c_expr_constructor}

\begin{syntax}
  \verb+TermExpr+ & $::=$ & \verb+SetExpr+\\
  & $|$ & \verb+MapExpr+\\
  & $|$ & \verb+ListExpr+\\
  & $|$ & \verb+RecordExpr+\\
\end{syntax}

% =======================================================================
% Set Expression
% =======================================================================

\subsection{Set Constructors}
\label{c_expr_set_constructor}

\begin{syntax}
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Map Expression
% =======================================================================

\subsection{Map Constructors}
\label{c_expr_map_constructor}

\begin{syntax}
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% List Expression
% =======================================================================

\subsection{List Constructors}
\label{c_expr_list_constructor}

\begin{syntax}
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Record Expression
% =======================================================================

\subsection{Record Constructors}
\label{c_expr_record_constructor}

\begin{syntax}
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Term Expressions
% =======================================================================

\section{Term Expressions}
\label{c_expr_term}

A {\em terminal expression} is one which can terminate an expression tree (though does not necessarily do so).  For example, a numeric literal represents a terminal node in an expression tree.

\begin{syntax}
  \verb+TermExpr+ & $::=$ & \verb+Ident+\\
  & $|$ & \verb+Literal+\\
\end{syntax}


% =======================================================================
% Lambda Expression
% =======================================================================

\section{Lambda Expression}
\label{c_expr_lambda}

\begin{syntax}
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

