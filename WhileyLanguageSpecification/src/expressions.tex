\chapter{Expressions}
The majority of work performed by a Whiley program is through the execution of \glspl{expression}.  Every expression produces a \gls{value} and may have additional side effects.

\section{Evaluation Order}

% =======================================================================
% Multi Expression
% =======================================================================

\section{Multi Expressions}
\label{c_expr_tuple}
A multi-expression is an expression composed of two or more unit expressions and which returns a tuple value (\S\ref{c_types_tuple}).  The operands of a multi-expression are evaluated in a strict left-to-right order.

\begin{syntax}
  \verb+TupleExpr+ & $::=$ & \verb+UnitExpr+ \big(\ \token{,}\ \verb+UnitExpr+\ \big)$^+$ \\
\end{syntax}

\paragraph{Example.}  The following example illustrates the use of a multi-expression:

\begin{lstlisting}
function scale(real x, real y, real p) => (real,real):
    return (x*p), (y*p)
\end{lstlisting}

This function accepts three \lstinline{real} values and returns two.  In the body, the \lstinline{return} statement contains a multi-expression which produces a tuple composed of two \lstinline{real} values.

% =======================================================================
% Unit Expression
% =======================================================================

\section{Unit Expressions}
\label{c_expr_unit}

A unit expression is an expression which returns exactly one value.  There is a large range of possible unit expressions, including comparators, arithmetic operators, logical operators, etc.

\begin{syntax}
  \verb+UnitExpr+ & $::=$ & \verb+LogicalExpr+\\
                  &  $|$  & \verb+BitwiseExpr+\\
                  &  $|$  & \verb+ConditionExpr+\\
                  &  $|$  & \verb+QuantifierExpr+\\
                  &  $|$  & \verb+AppendExpr+\\
                  &  $|$  & \verb+RangeExpr+\\
                  &  $|$  & \verb+ShiftExpr+\\
                  &  $|$  & \verb+AdditiveExpr+\\
                  &  $|$  & \verb+MultiplicativeExpr+\\
                  &  $|$  & \verb+AccessExpr+\\
                  &  $|$  & \verb+TermExpr+\\
                
\end{syntax}

% =======================================================================
% Logical Expressions
% =======================================================================

\section{Logical Expressions}
\label{c_expr_logical}

A logical expression operates on values of \lstinline{bool} type (\S\ref{c_types_bool}) to produce another \lstinline{bool} value.  The {\em if-and-only-if (iff)} operator, \lstinline{<==>}, returns \lstinline{true} if either both operands are \lstinline{true} or both are \lstinline{false}.  The {\em implication} operator, \lstinline{==>}, returns \lstinline{true} if either the left operand is \lstinline{false}, or both operands are \lstinline{true}.  The {\em logical OR} operator returns \lstinline{true} if either operand is \lstinline{true}, whilst the {\em logical AND} operator returns \lstinline{true} if both operands are \lstinline{true}.

\begin{syntax}
  \verb+LogicalExpr+ & $::=$ & \verb+LogicalOrExpr+ \big[ \token{<==>} \verb+LogicalExpr+\ \big]\\
                     &  $|$  & \verb+LogicalOrExpr+ \big[ \token{==>} \verb+LogicalExpr+\ \big]\\
  &&\\
  \verb+LogicalOrExpr+ & $::=$ & \verb+LogicalAndExpr+ \\
                           & $|$ & \verb+LogicalOrExpr+ \token{||} \verb+LogicalAndExpr+\\
  &&\\
  \verb+LogicalAndExpr+ & $::=$ & \verb+BitwiseExpr+ \\
                            & $|$ & \verb+LogicalAndExpr+ \token{\&\&} \verb+BitwiseExpr+\\
\end{syntax}

\paragraph{Example.}  The following examples illustrate some of the logical operators:

\begin{lstlisting}
function implies(bool x, bool y) => bool:
    return !x || y

function iff(bool x, bool y) => bool:
    return implies(x,y) && implies(y,x)
\end{lstlisting}

The function \lstinline{implies()} implements the well-known equivalence between implication and logical OR.  The function \lstinline{iff()} implements the well-known equivalence between implication and iff.

% =======================================================================
% Quantifier Expressions
% =======================================================================

\section{Quantifier Expressions}
\label{c_expr_quantifier}

\begin{syntax}
\verb+QuantExpr+ & $::=$ & \big(\ \token{no} $|$ \token{some} $|$
\token{all}\ \big)\ \token{\{}\\
&&\ \verb+Ident+ \token{in} \verb+Expr+ \big( \token{,}\ \verb+Ident+\
\token{in}\ \verb+Expr+\ \big)$^+$\ \token{|}\ \verb+LogicalExpr+\\
&& \token{\}}\\
\end{syntax}

\paragraph{Description.}

\paragraph{Examples.}

\paragraph{Notes.} 

% =======================================================================
% Bitwise Expressions
% =======================================================================

\section{Bitwise Expressions}
\label{c_expr_bitwise}
A bitwise expression operates on values of \lstinline{byte} type (\S\ref{c_types_byte}).  The {\em bitwise OR} operator, \lstinline{|}, performs a logical OR between the respective bits of each operand, and produces a \lstinline{byte}.  The {\em bitwise AND} operator, \lstinline{&}, performs a logical AND between the respective bits of each operand, and produces a \lstinline{byte}.   The {\em bitwise exclusive-OR} operator, \lstinline{^}, performs a logical exclusive-OR between the respective bits of each operand, and produces a \lstinline{byte}.

\begin{syntax}
  \verb+BitwiseExpr+ & $::=$ & \verb+BitwiseOrExpr+ \\
  &&\\
  \verb+BitwiseOrExpr+ & $::=$ & \verb+BitwiseXorExpr+ \\
                           & $|$ & \verb+BitwiseOrExpr+ \token{|} \verb+BitwiseXorExpr+\\
  &&\\
  \verb+BitwiseXorExpr+ & $::=$ & \verb+BitwiseAndExpr+ \\
                            & $|$ & \verb+BitwiseXorExpr+ \token{\^} \verb+BitwiseAndExpr+\\
  &&\\
  \verb+BitwiseAndExpr+ & $::=$ & \verb+ConditionExpr+ \\
                            & $|$ & \verb+BitwiseAndExpr+ \token{\&\&} \verb+ConditionExpr+\\

\end{syntax}

\paragraph{Example.}  The following example illustrates the bitwise OR operator:

\begin{lstlisting}
function toUnsignedByte(u8 v) => byte:
    //
    byte mask = 00000001b
    byte r = 0b
    for i in 0..8:
        if (v % 2) == 1:
            r = r | mask
        v = v / 2
        mask = mask << 1
    return r  
\end{lstlisting}

This function converts an unsigned integer in the range \lstinline{0} ... \lstinline{255} to a \lstinline{byte}.  The bitwise OR operator is used to construct the resulting \lstinline{byte} by setting individual bits via the \lstinline{mask}.  This example also illustrates the left-shift operator (\S\ref{c_expr_shift}).

% =======================================================================
% Condition Expressions
% =======================================================================

\section{Equality Expressions}
\label{c_expr_equality}
An equality expression compares two (or more) values together producing a value of \lstinline{bool} type.  The {\em equality comparator}, \lstinline{==}, tests whether two values are equal.  Likewise, the {\em inequality comparator}, \lstinline{==}, tests whether two values are {\em not} equal.

\begin{syntax}
  \verb+ConditionExpr+ & $::=$ &\\
  & $|$ & \verb+AppendExpr+ \token{==} \verb+AppendExpr+\\
  & $|$ & \verb+AppendExpr+ \token{!=} \verb+AppendExpr+\\
\end{syntax}

\paragraph{Example.}

The following example illustrates an equality expression:

\begin{lstlisting}
function contains([int] items, int item) => bool:
    //
    for i in items:
        if i == item:
            return true
    return false
\end{lstlisting}

This function checks whether a given integer is contained in a list of integers.  This is done by iterating each element of the list and comparing it against the given item.


\section{Relational Expressions}
\label{c_expr_relational}
A relational expression compares two (or more) values together producing a value of \lstinline{bool} type.  These are either {\em strict} (where only inequality is tested)  or {\em non-strict} (where both equality and inequality are tested).  The {\em less-than comparator}, \lstinline{<}, and {\em greater-than comparator}, \lstinline{>}, are strict.  Conversely, the {\em less-than-or-equal comparator}, \lstinline{<=}, and {\em greater-than-or-equal comparator}, \lstinline{>}, are non-strict.

\begin{syntax}
  \verb+ConditionExpr+ & $::=$ &\\
  & $|$ & \verb+AppendExpr+ \token{<} \verb+AppendExpr+\\
  & $|$ & \verb+AppendExpr+ \token{<=} \verb+AppendExpr+\\
  & $|$ & \verb+AppendExpr+ \token{=>} \verb+AppendExpr+\\
  & $|$ & \verb+AppendExpr+ \token{>} \verb+AppendExpr+\\
\end{syntax}

\paragraph{Example.} The following example illustrates the strict inequality comparators:

\begin{lstlisting}
function compare(int x, int y) => int:
    if x < y:
        return -1
    else if x > y:
        return 1
    else:
        return 0
\end{lstlisting}

This function compares two integer arguments and returns the ``sign'' of their comparison.  The strict inequality comparators are used so the case where \lstinline{x == y} can be distinguished.

\section{Subset Expressions}
\label{c_expr_relational}
A subset expression compares two (or more) values of set type (\S\ref{c_types_set}) together producing a value of \lstinline{bool} type.  These are either {\em strict} (where only inequality is tested)  or {\em non-strict} (where both equality and inequality are tested).  The {\em subset comparator}, ${\tt\subset}$, is strict.  Conversely, the {\em subset-or-equal comparator}, ${\tt\subseteq}$, is non-strict

\begin{syntax}
  \verb+ConditionExpr+ & $::=$ &\\
  & $|$ & \verb+AppendExpr+ \token{$\subset$} \verb+AppendExpr+\\
  & $|$ & \verb+AppendExpr+ \token{$\subseteq$} \verb+AppendExpr+\\
\end{syntax}

\paragraph{Example.} The following example illustrates the strict comparator:

\begin{lstlisting}
function compare({int} xs, {int} ys) => int:
    if xs $\subset$ ys:
        return -1
    else if ys $\subset$ xs:
        return 2
    else if xs == ys:
        return 1
    else:
        return 0
\end{lstlisting}

This function compares two integer sets and returns the ``sign'' of their comparison.  The non-strict inequality comparators are used so the cases where \lstinline{xs == ys} and \lstinline{xs != ys} can be distinguished.

\paragraph{Notes.}  At the time of writing there is no keyword or non-unicode operator for expressing these comparators.

\section{Element-Of Expression}
\label{c_expr_relational}
An element-of expression determines whether one value is contained within another value of collection type (\S\ref{c_types_collection}) and produces a value of \lstinline{bool} type.  Specifically, if the element is contained then the result is \lstinline{true}, otherwise it is \lstinline{false}.

\begin{syntax}
  \verb+ConditionExpr+ & $::=$ &\\
  & $|$ & \verb+AppendExpr+ \token{in} \verb+AppendExpr+\\
  & $|$ & \verb+AppendExpr+ \token{$\in$} \verb+AppendExpr+\\
\end{syntax}

\paragraph{Example.}  The following illustrates the element-of operator.

\begin{lstlisting}
function containsOne({int} xs, {int} ys):
    for x in xs:
        if x in ys:
            return true
    return false
\end{lstlisting}
This function accepts two integer sets and checks whether any element of the first parameter is in the second.

% =======================================================================
% Append Expressions
% =======================================================================

\section{Append Expressions}
\label{c_expr_append}

An append expression accepts two lists arguments and produces a value of list type.  The append operator, \lstinline{++}, concatenates the argument lists together, producing a list constructed from those elements of the first argument (in order0 followed by those of the second argument (in order).

\begin{syntax}
  \verb+AppendExpr+ & $::=$ & \verb+RangeExpr+\ \big(\ \token{++}\
  \verb+RangeExpr+\ \big)$^*$\\
\end{syntax}

\paragraph{Examples.} The following example illustrates the list append operator:
\begin{lstlisting}
function rangeOf(int start, int end) => [int]:
    [int] r = []
    int i = start
    while i < end:
        r = r ++ [i]
        i = i + 1
    return r
\end{lstlisting}

This function constructs a list containing the integer values from \lstinline{start} up to (but not including) \lstinline{end}.  The list append operator is used to construct the list, starting initially from the empty list.

% =======================================================================
% Range Expressions
% =======================================================================

\section{Range Expressions}
\label{c_expr_range}

A range expression accepts two integer arguments and produces a value of integer list type.  The {\em range operator} constructs the list of integer values from the first argument up to (but not including) the last.

\begin{syntax}
  \verb+RangeExpr+ & $::=$ & \verb+ShiftExpr+\ \big[\ \token{..}\ \verb+ShiftExpr+\ \big]\\
\end{syntax}

\paragraph{Examples.}  The following illustrates the range operator:

\begin{lstlisting}
function sum(int start, int end) => [int]:
    int r = 0
    for i in start .. end:
        r = r + i
    return r
\end{lstlisting}

This function sums the integers between \lstinline{start} and \lstinline{end}.  The range operator is used to construct the list to be iterated over.

\paragraph{Notes.}  If the start of a range expression is greater than its end, the empty list is returned.

% =======================================================================
% Shift Expressions
% =======================================================================

\section{Shift Expressions}
\label{c_expr_shift}

A shift expression accepts an argument of \lstinline{byte} type (left) and one of \lstinline{int} type (right) and produces a value of \lstinline{byte} type.  The {\em left shift operator}, \lstinline{<<}, shifts the bits of a \lstinline{byte} in an upwards direction, such that the most significant bit is discarded and the least significant bit assigned \lstinline{0}.  The {\em right shift operator}, \lstinline{>>}, shifts bits in a downwards direction, such that the least significant bit is discarded and the most significant bit assigned \lstinline{0}.  

\begin{syntax}
  \verb+ShiftExpr+ & $::=$ & \verb+AdditiveExpr+\ \big[\ \big(\
  \token{<<} $|$ \token{>>}\ \big)\ \verb+AdditiveExpr+ \big]
\end{syntax}

\paragraph{Examples.} The following illustrates the left shift operator:

\begin{lstlisting}
public function toUnsignedByte(u8 v) => byte:
    //
    byte mask = 00000001b
    byte r = 0b
    for i in 0..8:
        if (v % 2) == 1:
            r = r | mask
        v = v / 2
        mask = mask << 1
    return r
\end{lstlisting}

This function accepts an integer between \lstinline{0} and \lstinline{255} and converts this into an appropriate bit representation.  The left shift operator is used to maintain an internal mask for the bit currently being initialised.

% =======================================================================
% Addititve and Multiplicative Expressions
% =======================================================================

\section{Additive/Multiplicative Expressions}
\label{c_expr_addmul}

\begin{syntax}
  \verb+AdditiveExpr+ & $::=$ &\\
  \verb+MultiplicativeExpr+ & $::=$ &\\
\end{syntax}

\paragraph{Description.}

\paragraph{Examples.}

\paragraph{Notes.} 

% =======================================================================
% Access Expressions
% =======================================================================

\section{Access Expressions}
\label{c_expr_access}

\begin{syntax}
  \verb+AccessExpr+ & $::=$ &\\
\end{syntax}

\paragraph{Description.}

\paragraph{Examples.}

\paragraph{Notes.} 

% =======================================================================
% Term Expressions
% =======================================================================

\section{Term Expressions}
\label{c_expr_term}

\begin{syntax}
  \verb+TermExpr+ & $::=$ &\\
\end{syntax}

\paragraph{Description.}

\paragraph{Examples.}

\paragraph{Notes.} 

% =======================================================================
% Dereference Expressions
% =======================================================================

\section{Dereference Expressions}
\label{c_expr_dereference}


 The dereference operation ``\lstinline{e->f}'' is a short-hand notation for ``\lstinline{(*e).f}'' and can be used when \lstinline{e} has effective record type (\S\ref{c_types_effective_records}).

