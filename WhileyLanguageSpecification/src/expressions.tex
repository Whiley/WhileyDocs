
\chapter{Expressions}
The majority of work performed by a Whiley program is through the execution of \glspl{expression}.  Every expression produces a \gls{value} and may have additional side effects.

\section{Evaluation Order}

\section{Operator Precedence}

% =======================================================================
% Multi Expression
% =======================================================================

\section{Multi Expressions}
\label{c_expr_tuple}
A multi-expression is an expression composed of two or more unit expressions and which returns a tuple value (\S\ref{c_types_tuple}).  The operands of a multi-expression are evaluated in a strict left-to-right order.

\begin{syntax}
  \verb+Expr+ & $::=$ & \verb+UnitExpr+ \big(\ \token{,}\ \verb+UnitExpr+\ \big)$^+$ \\
\end{syntax}

\paragraph{Example.}  The following example illustrates the use of a multi-expression:

\lstinputlisting{../examples/ch6/eg_1.whiley}

This function accepts three \lstinline{real} values and returns two.  In the body, the \lstinline{return} statement contains a multi-expression which produces a tuple composed of two \lstinline{real} values.

% =======================================================================
% Unit Expression
% =======================================================================

\section{Unit Expressions}
\label{c_expr_unit}

A unit expression is an expression which returns exactly one value.  There is a large range of possible unit expressions, including comparators, arithmetic operators, logical operators, etc.

\begin{syntax}
  \verb+UnitExpr+ & $::=$ & \verb+ArithmeticExpr+\\
                  &  $|$  & \verb+BitwiseExpr+\\
                  &  $|$  & \verb+CastExpr+\\
                  &  $|$  & \verb+EqualityExpr+\\
                  &  $|$  & \verb+InvokeExpr+\\
                  &  $|$  & \verb+LambdaExpr+\\
                  &  $|$  & \verb+LogicalExpr+\\
                  &  $|$  & \verb+ListExpr+\\
                  &  $|$  & \verb+RecordExpr+\\
                  &  $|$  & \verb+ReferenceExpr+\\
                  &  $|$  & \verb+TermExpr+\\
                
\end{syntax}

% =======================================================================
% Binary Expressions
% =======================================================================

\section{Arithmetic Expressions}
\label{c_expr_arithmetic}

Arithmetic expressions operate on values of numerical type (either \lstinline{int} or \lstinline{real}).

\begin{syntax}
  \verb+ArithmeticExpr+ & $::=$ & \verb+ArithmeticNegationExpr+\\
                  &  $|$  & \verb+ArithmeticRelationalExpr+\\
                  &  $|$  & \verb+ArithmeticAdditiveExpr+\\
                  &  $|$  & \verb+ArithmeticMultiplicativeExpr+\\
\end{syntax}

% =======================================================================
% Negation Expression
% =======================================================================

\subsection{Negation Expressions}
\label{c_expr_negation}

A negation expression accepts one argument of numeric type and produces a result of matching type.  Specifically, the {\em negation operator} mathematically negates the given value, which is always equivalent to subtracting the operand from zero.

\begin{syntax}
\verb+ArithmeticNegationExpr+ & $::=$ & \token{-}\ \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.} The following illustrates the negation operator:

\lstinputlisting{../examples/ch6/eg_13.whiley}

% =======================================================================
% Relational Expressions
% =======================================================================

\subsection{Relational Expressions}
\label{c_expr_relational}
Relational expressions are either {\em strict} (where only inequality is tested)  or {\em non-strict} (where both equality and inequality are tested).  The {\em less-than comparator}, \lstinline{<}, and {\em greater-than comparator}, \lstinline{>}, are strict.  Conversely, the {\em less-than-or-equal comparator}, \lstinline{<=}, and {\em greater-than-or-equal comparator}, \lstinline{>}, are non-strict.

\begin{syntax}
  \verb+ArithmeticRelationalExpr+ & $::=$ &\\
  & $|$ & \verb+UnitExpr+ \token{<} \verb+UnitExpr+\\
  & $|$ & \verb+UnitExpr+ \token{<=} \verb+UnitExpr+\\
  & $|$ & \verb+UnitExpr+ \token{=>} \verb+UnitExpr+\\
  & $|$ & \verb+UnitExpr+ \token{>} \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.} The following example illustrates the strict inequality comparators:

\lstinputlisting{../examples/ch6/eg_5.whiley}

This function compares two integer arguments and returns the ``sign'' of their comparison.  The strict inequality comparators are used so the case where \lstinline{x == y} can be distinguished.

% =======================================================================
% Addititve and Multiplicative Expressions
% =======================================================================

\subsection{Additive Expressions}
\label{c_expr_additive}

An additive expression accepts two arguments of identical type (either \lstinline{int} or \lstinline{real}) and produces a result of matching type.  The {\em addition operator}, \lstinline{+}, adds both arguments together whilst the {\em subtraction operator}, \lstinline{-}, subtracts its right argument from its left argument.

\begin{syntax}
  \verb+ArithmeticAdditiveExpr+ & $::=$ & \verb+UnitExpr+ \big(\ \token{+} $|$ \token{-}\ \big) \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.}  The following illustrates the additive operators:

\lstinputlisting{../examples/ch6/eg_11.whiley}

This function simply computes the difference between its two arguments using the subtraction operator.


\subsection{Multiplicative Expressions}
\label{c_expr_multiplicative}

A multiplicative expression accepts two arguments of identical type (either \lstinline{int} or \lstinline{real}) and produces a result of matching type.  The {\em multiplication operator}, \lstinline{*}, multiplies both arguments together whilst the {\em division operator}, \lstinline{/}, divides its left argument by its right argument.  Finally, the {\em remainder operator} returns the remainder of its operands from an implied division.  

\begin{syntax}
  \verb+ArithmeticMultiplicativeExpr+ & $::=$ & \verb+UnitExpr+ \big(\ \token{*} $|$ \token{/} $|$ \token{\%}\ \big) \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.} The following illustrates the remainder operator:

\lstinputlisting{../examples/ch6/eg_12.whiley}

This function accepts a non-negative integer and uses this to index into a list.  To ensure the list access is within bounds, the remainder operator is used.  Furthermore, the function requires the list is non-empty to prevent a fault with the remainder operator.

\paragraph{Notes.}  For division, the right operator must be non-zero otherwise a \gls{fault} is raised, and likewise for remainder.  For integer division, the result is rounded towards zero.  For a remainder operation, the result may be negative (e.g. \lstinline{-4 % 3 == -1}).

% =======================================================================
% Bitwise Expressions
% =======================================================================

\section{Bitwise Expressions}
\label{c_expr_bitwise}

Bitwise expressions operate on values of \lstinline{byte} type.

\begin{syntax}
  \verb+BitwiseExpr+ & $::=$ & \verb+BitwiseComplementExpr+\\
                  &  $|$  & \verb+BitwiseBinaryExpr+\\
                  &  $|$  & \verb+BitwiseShiftExpr+\\
\end{syntax}

% =======================================================================
% Bitwise Complement Expression
% =======================================================================

\subsection{Complement Expressions}
\label{c_expr_bitwise_complement}
The {\em bitwise complement operator} accepts an argument of \lstinline{byte} type (\S\ref{c_types_byte}) and produces a result of matching type.  The operator returns bitwise complement of the argument; that is, where the sign of each bit is reversed.

\begin{syntax}
\verb+BitwiseComplementExpr+ & $::=$ & \token{$\sim$}\ \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.}  The following example illustrates the bitwise complement operator:

\lstinputlisting{../examples/ch6/eg_15.whiley}

\subsection{Binary Expressions}
\label{c_expr_bitwise_binary}
A bitwise binary expression operates on values of \lstinline{byte} type (\S\ref{c_types_byte}).  The {\em bitwise AND} operator, \lstinline{&}, performs a logical AND between the respective bits of each operand, and produces a \lstinline{byte}.   The {\em bitwise OR} operator, \lstinline{|}, performs a logical OR between the respective bits of each operand, and produces a \lstinline{byte}.  The {\em bitwise exclusive-OR} operator, \lstinline{^}, performs a logical exclusive-OR between the respective bits of each operand, and produces a \lstinline{byte}.

\begin{syntax}
  \verb+BitwiseBinaryExpr+ & $::=$ & \verb+UnitExpr+ \big(\ \token{\&} $|$ \token{|}\ $|$ \token{\^}\ \big) \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.}  The following example illustrates the bitwise OR operator:

\lstinputlisting[firstline=3]{../examples/ch6/eg_3.whiley}

This function converts an unsigned integer in the range \lstinline{0} ... \lstinline{255} to a \lstinline{byte}.  The bitwise OR operator is used to construct the resulting \lstinline{byte} by setting individual bits via the \lstinline{mask}.  This example also illustrates the left-shift operator (\S\ref{c_expr_shift}).

% =======================================================================
% Shift Expressions
% =======================================================================

\subsection{Shift Expressions}
\label{c_expr_shift}

A bitwise shift expression accepts an argument of \lstinline{byte} type (left) and one of \lstinline{int} type (right) and produces a value of \lstinline{byte} type.  The {\em left shift operator}, \lstinline{<<}, shifts the bits of a \lstinline{byte} in an upwards direction, such that the most significant bit is discarded and the least significant bit assigned \lstinline{0}.  The {\em right shift operator}, \lstinline{>>}, shifts bits in a downwards direction, such that the least significant bit is discarded and the most significant bit assigned \lstinline{0}.  

\begin{syntax}
  \verb+BitwiseShiftExpr+ & $::=$ & \verb+UnitExpr+\ \big[\ \big(\
  \token{<<} $|$ \token{>>}\ \big)\ \verb+UnitExpr+ \big]
\end{syntax}

\paragraph{Examples.} The following illustrates the left shift operator:

\lstinputlisting[firstline=3]{../examples/ch6/eg_10.whiley}

This function accepts an integer between \lstinline{0} and \lstinline{255} and converts this into an appropriate bit representation.  The left shift operator is used to maintain an internal mask for the bit currently being initialised.

% =======================================================================
% Cast Expressions
% =======================================================================

\section{Cast Expressions}
\label{c_expr_cast}
A {\em cast operator} accepts a value of one type and returns a value of a different, but equivalent, type and this may result in a change of the underlying representation.  

\begin{syntax}
\verb+CastExpr+ & $::=$ & \token{(}\ \verb+DefiniteType+ \token{)}\ \verb+Expr+\\
\end{syntax}

\paragraph{Example.}  The following illustrates a cast operator being used:

\lstinputlisting[firstline=3]{../examples/ch6/eg_16.whiley}

This function converts a record containing two {\em int} fields into one containing two \lstinline{real} fields using a cast.

% =======================================================================
% Equality Expression
% =======================================================================

\section{Equality Expressions}
\label{c_expr_equality}
The {\em equality comparator}, \lstinline{==}, tests whether two values are equal.  Likewise, the {\em inequality comparator}, \lstinline{!=}, tests whether two values are {\em not} equal.

\begin{syntax}
  \verb+EqualityExpr+ & $::=$ &\\
  & $|$ & \verb+Expr+ \token{==} \verb+Expr+\\
  & $|$ & \verb+Expr+ \token{!=} \verb+Expr+\\
\end{syntax}

\paragraph{Example.}

The following example illustrates an equality expression:

\lstinputlisting{../examples/ch6/eg_4.whiley}

This function checks whether a given integer is contained in a list of integers.  This is done by iterating each element of the list and comparing it against the given item.

% =======================================================================
% Invocation Expression
% =======================================================================

\section{Invoke Expressions}
\label{c_expr_invoke}
An {\em function or method invocation} executes a named function or method declared in a given source file.  An invocation passes arguments of appropriate number and type to the executed function or method.  An invocation may also return one or more values which can be subsequently used.

% Could also discuss function or method lookup; this is really part of typing.

\begin{syntax}
  \verb+InvokeExpr+ & $::=$ & \verb+Name+ \token{(} \big[ \verb+Expr+ \big( \token{,} \verb+Expr+ \big)$^*$ \big] \token{)}\\
\end{syntax}

\paragraph{Example.}

The following example illustrates an equality expression:

\lstinputlisting{../examples/ch6/eg_17.whiley}

This example illustrates one function being called from another.  Both functions have the same name and are said to {\em overload} one another.  Function resolution identifies the appropriate function based on the number and type of arguments supplied.  

% =======================================================================
% LambdaExpression
% =======================================================================

\section{Lambda Expressions}
\label{c_expr_lambda}

\begin{syntax}
  \verb+LambdaExpr+ & $::=$ &\\
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Logical Expressions
% =======================================================================

\section{Logical Expressions}
\label{c_expr_logical}

Logical expressions operate on values of \lstinline{bool} type.

\begin{syntax}
  \verb+LogicalExpr+ & $::=$ &\\
  & $|$ & \verb+LogicalNotExpr+\\
  & $|$ & \verb+LogicalBinaryExpr+\\
  & $|$ & \verb+LogicalQuantExpr+\\
\end{syntax}


% =======================================================================
% Logical Not Expression
% =======================================================================

\subsection{Not Expressions}
\label{c_expr_logical_not}

The {\em logical not} operator accepts an argument of \lstinline{bool} type and produces a value of \lstinline{bool}.  The value returned is the logical opposite of the argument.  

\begin{syntax}
\verb+LogicalNotExpr+ & $::=$ & \token{!}\ \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.}

The following example illustrates an equality expression:

\lstinputlisting{../examples/ch6/eg_18.whiley}

This function computes the maximum of two \lstinline{int} values.  The expression \lstinline{!(a < b)} is equivalent to \lstinline{a >= b} and is used purely to illustrate the logical not operator.

% =======================================================================
% Logical Binary Expressions
% =======================================================================

\subsection{Connective Expressions}
\label{c_expr_logical_binary}

A logical connective operates on values of \lstinline{bool} type (\S\ref{c_types_bool}) to produce another \lstinline{bool} value.  The {\em if-and-only-if (iff)} operator, \lstinline{<==>}, returns \lstinline{true} if either both operands are \lstinline{true} or both are \lstinline{false}.  The {\em implication} operator, \lstinline{==>}, returns \lstinline{true} if either the left operand is \lstinline{false}, or both operands are \lstinline{true}.  The {\em logical OR} operator returns \lstinline{true} if either operand is \lstinline{true}, whilst the {\em logical AND} operator returns \lstinline{true} if both operands are \lstinline{true}.

\begin{syntax}

  \verb+LogicalBinaryExpr+ & $::=$ & \verb+UnitExpr+ \big(\ \token{<==>} $|$ \token{==>} $|$ \token{\&\&} $|$ \token{||}\ \big) \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.}  The following examples illustrate some of the logical operators:

\lstinputlisting{../examples/ch6/eg_2.whiley}

The function \lstinline{implies()} implements the well-known equivalence between implication and logical OR.  The function \lstinline{iff()} implements the well-known equivalence between implication and iff.

% =======================================================================
% Quantifier Expressions
% =======================================================================

\subsection{Quantifier Expressions}
\label{c_expr_quantifier}

A quantifier operates over a list of values and produces a value of \lstinline{bool} type.  The {\em universal quantifier}, \lstinline{all}, returns \lstinline{true} if the given expression evaluates to \lstinline{true} for every element in the list, and \lstinline{false} otherwise.  The {\em existential quantifier}, \lstinline{exists}, returns \lstinline{false} if the given expression evaluates to \lstinline{false} for every element in the list, and \lstinline{true} otherwise.  The {\em inverted universal quantifier}, \lstinline{no}, returns \lstinline{true} if the given expression evaluates to \lstinline{false} for every element in the list, and \lstinline{false} otherwise

\begin{syntax}
\verb+LogicalQuantExpr+ & $::=$ & \big(\ \token{no} $|$ \token{some} $|$
\token{all}\ \big)\ \token{\{}\\
&&\ \verb+Ident+ \token{in} \verb+UnitExpr+ \big( \token{,}\ \verb+Ident+\
\token{in}\ \verb+UnitExpr+\ \big)$^*$\\
&&  \token{|}\ \verb+Expr+\ \token{\}}\\
\end{syntax}

\paragraph{Examples.}  The following examples illustrate the universal quantifier:

\lstinputlisting{../examples/ch6/eg_18.whiley}

Here, the type \lstinline{natlist} represents those integer lists for which every element is a natural number (i.e. greater-or-equal to zero).

% =======================================================================
% List Expressions
% =======================================================================

\section{List Expressions}
\label{c_expr_list}

List expressions operate on values of list type (e.g. \lstinline{[int]}, \lstinline{[bool|real]}, etc).


\begin{syntax}
  \verb+ListExpr+ & $::=$ &\\
  & $|$ & \verb+ListLengthOfExpr+\\
  & $|$ & \verb+ListAccessExpr+\\
  & $|$ & \verb+ListAppendExpr+\\
  & $|$ & \verb+ListRangeExpr+\\
  & $|$ & \verb+ListConstructorExpr+\\
\end{syntax}

% =======================================================================
% LengthOf Expression
% =======================================================================

\subsection{LengthOf Expressions}
\label{c_expr_lengthof}

The {\em lengthof operator} accepts a value of list type, and produces a value of \lstinline{int} type which equals the number of elements in the list.

\begin{syntax}
\verb+ListLengthOfExpr+ & $::=$ & \token{|}\ \verb+Expr+\ \token{|}\\
\end{syntax}

\paragraph{Example.} The following examples illustrate the length of operator:

\lstinputlisting{../examples/ch6/eg_19.whiley}

The above function iterates through all elements in a list looking for the first which is above a given item.  The lengthof operator is used to ensure this iteration remains within bounds.

% =======================================================================
% List Access Expressions
% =======================================================================

\subsection{Access Expressions}
\label{c_expr_list_access}

\begin{syntax}
  \verb+ListAccessExpr+ & $::=$ & \verb+UnitExpr+\\
   &  \big( &\token{[}\ \verb+Expr+\ \token{]}\\
   & $|$ & \token{[}\ \verb+Expr+\ \token{..}\ \verb+Expr+\ \token{]}\\
   & \big)$^+$&\\
\end{syntax}

\paragraph{Description.}

The {\em arrow operator} returns a field of the value referenced by the argument.

\paragraph{Examples.}

\paragraph{Notes.} The arrow operation ``\lstinline{e->f}'' is a short-hand notation for ``\lstinline{(*e).f}'' and can be used when \lstinline{e} has effective record type (\S\ref{c_types_effective_records}).

% =======================================================================
% Append Expressions
% =======================================================================

\subsection{Append Expressions}
\label{c_expr_append}

An append expression accepts two lists arguments and produces a value of list type.  The append operator, \lstinline{++}, concatenates the argument lists together, producing a list constructed from those elements of the first argument (in order) followed by those of the second argument (in order).

\begin{syntax}
  \verb+ListAppendExpr+ & $::=$ & \verb+UnitExpr+\ \big(\ \token{++}\
  \verb+UnitExpr+\ \big)$^*$\\
\end{syntax}

\paragraph{Examples.} The following example illustrates the list append operator:

\lstinputlisting{../examples/ch6/eg_8.whiley}

This function constructs a list containing the integer values from \lstinline{start} up to (but not including) \lstinline{end}.  The list append operator is used to construct the list, starting initially from the empty list.

% =======================================================================
% Range Expressions
% =======================================================================

\subsection{Range Expressions}
\label{c_expr_range}

A range expression accepts two integer arguments and produces a value of integer list type.  The {\em range operator} constructs the list of integer values from the first argument up to (but not including) the last.

\begin{syntax}
  \verb+ListRangeExpr+ & $::=$ & \verb+UnitExpr+\ \token{..}\ \verb+UnitExpr+\\
\end{syntax}

\paragraph{Examples.}  The following illustrates the range operator:

\lstinputlisting{../examples/ch6/eg_9.whiley}

This function sums the integers between \lstinline{start} and \lstinline{end}.  The range operator is used to construct the list to be iterated over.

\paragraph{Notes.}  If the start of a range expression is greater than its end, the empty list is returned.

% =======================================================================
% List Expression
% =======================================================================

\subsection{Constructor Expressions}
\label{c_expr_list_constructor}

\begin{syntax}
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Record Expressions
% =======================================================================

\section{Record Expressions}
\label{c_expr_record}

% =======================================================================
% Field Access Expressions
% =======================================================================

\subsection{Field Access Expressions}
\label{c_expr_field_access}

\begin{syntax}
  \verb+FieldAccessExpr+ & $::=$ & \verb+UnitExpr+\\
   &  \big( &\token{.}\ \verb+Ident+\ \big[\ \token{(}\ \verb+ArgsList+\ \token{)}\ \big]\\
   & $|$ & \token{->}\ \verb+Ident+\ \big[\ \token{(}\ \verb+ArgsList+\ \token{)}\ \big]\\
   & \big)$^+$&\\
&&\\
\verb+ArgsList+ & $::=$ & \big[\ \verb+UnitExpr+\ \big(\ \token{,}\ \verb+UnitExpr+\ \big)$^*$\ \big]\\
\end{syntax}

\paragraph{Description.}

The {\em arrow operator} returns a field of the value referenced by the argument.

\paragraph{Examples.}

\paragraph{Notes.} The arrow operation ``\lstinline{e->f}'' is a short-hand notation for ``\lstinline{(*e).f}'' and can be used when \lstinline{e} has effective record type (\S\ref{c_types_effective_records}).


% =======================================================================
% Record Expression
% =======================================================================

\subsection{Record Constructors}
\label{c_expr_record_constructor}

\begin{syntax}
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Reference Expressions
% =======================================================================
\section{Reference Expressions}

% =======================================================================
% New Expression
% =======================================================================

\subsection{New Expressions}
\label{c_expr_new}

\begin{syntax}
\verb+NewExpr+ & $::=$ & \token{new}\ \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Dereference Expressions
% =======================================================================

\subsection{Dereference Expressions}
\label{c_expr_dereference}

A {\em dereference expression} accepts an argument of reference type and returns a value (or element) of the reference's target type.  The {\em dereference operator} returns the value referenced by the argument.  

\begin{syntax}
  \verb+DereferenceExpr+ & $::=$ & \token{*}\ \verb+TermExpr+\\\
  & $|$ & \verb+TermExpr+\ \token{->}\ \verb+Identifier+\\
\end{syntax}

\paragraph{Example.} The following illustrates the dereference operator:

\lstinputlisting{../examples/ch6/eg_14.whiley}

This function traverses a linked list counting the number of links it contains.  The arrow operator is used to access the next link in the chain.

\paragraph{Notes.}

% =======================================================================
% Term Expressions
% =======================================================================

\section{Terminal Expressions}
\label{c_expr_term}

A {\em terminal expression} is one which can terminate an expression tree (though does not necessarily do so).  For example, a numeric literal represents a terminal node in an expression tree.

\begin{syntax}
  \verb+TermExpr+ & $::=$ & \verb+Ident+\\
  & $|$ & \verb+Literal+\\
  & $|$ & \token{(}\ \verb+Expr+\ \token{)}\\
\end{syntax}

