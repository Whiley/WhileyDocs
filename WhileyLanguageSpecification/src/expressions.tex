
\chapter{Expressions}
The majority of work performed by a Whiley program is through the execution of \glspl{expression}.  Every expression produces a \gls{value} and may have additional side effects.

\section{Evaluation Order}

\section{Operator Precedence}

% =======================================================================
% Multi Expression
% =======================================================================

\section{Multi Expressions}
\label{c_expr_tuple}
A multi-expression is an expression composed of two or more unit expressions and which returns a tuple value (\S\ref{c_types_tuple}).  The operands of a multi-expression are evaluated in a strict left-to-right order.

\begin{syntax}
  \verb+Expr+ & $::=$ & \verb+UnitExpr+ \big(\ \token{,}\ \verb+UnitExpr+\ \big)$^+$ \\
\end{syntax}

\paragraph{Example.}  The following example illustrates the use of a multi-expression:

\lstinputlisting{../examples/ch6/eg_1.whiley}

This function accepts three \lstinline{real} values and returns two.  In the body, the \lstinline{return} statement contains a multi-expression which produces a tuple composed of two \lstinline{real} values.

% =======================================================================
% Unit Expression
% =======================================================================

\section{Unit Expressions}
\label{c_expr_unit}

A unit expression is an expression which returns exactly one value.  There is a large range of possible unit expressions, including comparators, arithmetic operators, logical operators, etc.

\begin{syntax}
  \verb+UnitExpr+ & $::=$ & \verb+ArithmeticExpr+\\
                  &  $|$  & \verb+BitwiseExpr+\\
                  &  $|$  & \verb+CastExpr+\\
                  &  $|$  & \verb+EqualityExpr+\\
                  &  $|$  & \verb+InvokeExpr+\\
                  &  $|$  & \verb+LambdaExpr+\\
                  &  $|$  & \verb+LogicalExpr+\\
                  &  $|$  & \verb+ListExpr+\\
                  &  $|$  & \verb+RecordExpr+\\
                  &  $|$  & \verb+ReferenceExpr+\\
                  &  $|$  & \verb+TermExpr+\\
                
\end{syntax}

% =======================================================================
% Binary Expressions
% =======================================================================

\section{Arithmetic Expressions}
\label{c_expr_arithmetic}

Arithmetic expressions operate on values of numerical type (either \lstinline{int} or \lstinline{real}).

\begin{syntax}
  \verb+ArithmeticExpr+ & $::=$ & \verb+ArithmeticNegationExpr+\\
                  &  $|$  & \verb+ArithmeticRelationalExpr+\\
                  &  $|$  & \verb+ArithmeticAdditiveExpr+\\
                  &  $|$  & \verb+ArithmeticMultiplicativeExpr+\\
\end{syntax}

% =======================================================================
% Negation Expression
% =======================================================================

\subsection{Negation Expressions}
\label{c_expr_negation}

A negation expression accepts one argument of numeric type and produces a result of matching type.  Specifically, the {\em negation operator} mathematically negates the given value, which is always equivalent to subtracting the operand from zero.

\begin{syntax}
\verb+ArithmeticNegationExpr+ & $::=$ & \token{-}\ \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.} The following illustrates the negation operator:

\lstinputlisting{../examples/ch6/eg_13.whiley}

\paragraph{Notes.}

% =======================================================================
% Relational Expressions
% =======================================================================

\subsection{Relational Expressions}
\label{c_expr_relational}
Relational expressions are either {\em strict} (where only inequality is tested)  or {\em non-strict} (where both equality and inequality are tested).  The {\em less-than comparator}, \lstinline{<}, and {\em greater-than comparator}, \lstinline{>}, are strict.  Conversely, the {\em less-than-or-equal comparator}, \lstinline{<=}, and {\em greater-than-or-equal comparator}, \lstinline{>}, are non-strict.

\begin{syntax}
  \verb+ArithmeticRelationalExpr+ & $::=$ &\\
  & $|$ & \verb+UnitExpr+ \token{<} \verb+UnitExpr+\\
  & $|$ & \verb+UnitExpr+ \token{<=} \verb+UnitExpr+\\
  & $|$ & \verb+UnitExpr+ \token{=>} \verb+UnitExpr+\\
  & $|$ & \verb+UnitExpr+ \token{>} \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.} The following example illustrates the strict inequality comparators:

\lstinputlisting{../examples/ch6/eg_5.whiley}

This function compares two integer arguments and returns the ``sign'' of their comparison.  The strict inequality comparators are used so the case where \lstinline{x == y} can be distinguished.

% =======================================================================
% Addititve and Multiplicative Expressions
% =======================================================================

\subsection{Additive Expressions}
\label{c_expr_additive}

An additive expression accepts two arguments of identical type (either \lstinline{int} or \lstinline{real}) and produces a result of matching type.  The {\em addition operator}, \lstinline{+}, adds both arguments together whilst the {\em subtraction operator}, \lstinline{-}, subtracts its right argument from its left argument.

\begin{syntax}
  \verb+ArithmeticAdditiveExpr+ & $::=$ & \verb+UnitExpr+ \big(\ \token{+} $|$ \token{-}\ \big) \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.}  The following illustrates the additive operators:

\lstinputlisting{../examples/ch6/eg_11.whiley}

This function simply computes the difference between its two arguments using the subtraction operator.


\subsection{Multiplicative Expressions}
\label{c_expr_multiplicative}

A multiplicative expression accepts two arguments of identical type (either \lstinline{int} or \lstinline{real}) and produces a result of matching type.  The {\em multiplication operator}, \lstinline{*}, multiplies both arguments together whilst the {\em division operator}, \lstinline{/}, divides its left argument by its right argument.  Finally, the {\em remainder operator} returns the remainder of its operands from an implied division.  

\begin{syntax}
  \verb+ArithmeticMultiplicativeExpr+ & $::=$ & \verb+UnitExpr+ \big(\ \token{*} $|$ \token{/} $|$ \token{\%}\ \big) \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.} The following illustrates the remainder operator:

\lstinputlisting{../examples/ch6/eg_12.whiley}

This function accepts a non-negative integer and uses this to index into a list.  To ensure the list access is within bounds, the remainder operator is used.  Furthermore, the function requires the list is non-empty to prevent a fault with the remainder operator.

\paragraph{Notes.}  For division, the right operator must be non-zero otherwise a \gls{fault} is raised, and likewise for remainder.  For integer division, the result is rounded towards zero.  For a remainder operation, the result may be negative (e.g. \lstinline{-4 % 3 == -1}).

% =======================================================================
% Bitwise Expressions
% =======================================================================

\section{Bitwise Expressions}
\label{c_expr_bitwise}

Bitwise expressions operate on values of \lstinline{byte} type.

\begin{syntax}
  \verb+BitwiseExpr+ & $::=$ & \verb+BitwiseComplementExpr+\\
                  &  $|$  & \verb+BitwiseBinaryExpr+\\
                  &  $|$  & \verb+BitwiseShiftExpr+\\
\end{syntax}

% =======================================================================
% Bitwise Complement Expression
% =======================================================================

\subsection{Complement Expressions}
\label{c_expr_bitwise_complement}

\begin{syntax}
\verb+BitwiseComplementExpr+ & $::=$ & \token{~}\ \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

\subsection{Binary Expressions}
\label{c_expr_bitwise_binary}
A bitwise expression operates on values of \lstinline{byte} type (\S\ref{c_types_byte}).  The {\em bitwise AND} operator, \lstinline{&}, performs a logical AND between the respective bits of each operand, and produces a \lstinline{byte}.   The {\em bitwise OR} operator, \lstinline{|}, performs a logical OR between the respective bits of each operand, and produces a \lstinline{byte}.  The {\em bitwise exclusive-OR} operator, \lstinline{^}, performs a logical exclusive-OR between the respective bits of each operand, and produces a \lstinline{byte}.

\begin{syntax}
  \verb+BitwiseBinaryExpr+ & $::=$ & \verb+UnitExpr+ \big(\ \token{\&} $|$ \token{|}\ $|$ \token{\^}\ \big) \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.}  The following example illustrates the bitwise OR operator:

\lstinputlisting[firstline=3]{../examples/ch6/eg_3.whiley}

This function converts an unsigned integer in the range \lstinline{0} ... \lstinline{255} to a \lstinline{byte}.  The bitwise OR operator is used to construct the resulting \lstinline{byte} by setting individual bits via the \lstinline{mask}.  This example also illustrates the left-shift operator (\S\ref{c_expr_shift}).

% =======================================================================
% Shift Expressions
% =======================================================================

\subsection{Shift Expressions}
\label{c_expr_shift}

A bitwise shift expression accepts an argument of \lstinline{byte} type (left) and one of \lstinline{int} type (right) and produces a value of \lstinline{byte} type.  The {\em left shift operator}, \lstinline{<<}, shifts the bits of a \lstinline{byte} in an upwards direction, such that the most significant bit is discarded and the least significant bit assigned \lstinline{0}.  The {\em right shift operator}, \lstinline{>>}, shifts bits in a downwards direction, such that the least significant bit is discarded and the most significant bit assigned \lstinline{0}.  

\begin{syntax}
  \verb+BitwiseShiftExpr+ & $::=$ & \verb+UnitExpr+\ \big[\ \big(\
  \token{<<} $|$ \token{>>}\ \big)\ \verb+UnitExpr+ \big]
\end{syntax}

\paragraph{Examples.} The following illustrates the left shift operator:

\lstinputlisting[firstline=3]{../examples/ch6/eg_10.whiley}

This function accepts an integer between \lstinline{0} and \lstinline{255} and converts this into an appropriate bit representation.  The left shift operator is used to maintain an internal mask for the bit currently being initialised.

% =======================================================================
% Cast Expressions
% =======================================================================

\section{Cast Expressions}
\label{c_expr_cast}

\begin{syntax}
\verb+CastExpr+ & $::=$ & \token{(}\ \verb+DefiniteType+ \token{)}\ \verb+Expr+\\
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Equality Expression
% =======================================================================

\section{Equality Expressions}
\label{c_expr_equality}
The {\em equality comparator}, \lstinline{==}, tests whether two values are equal.  Likewise, the {\em inequality comparator}, \lstinline{!=}, tests whether two values are {\em not} equal.

\begin{syntax}
  \verb+EqualityExpr+ & $::=$ &\\
  & $|$ & \verb+Expr+ \token{==} \verb+Expr+\\
  & $|$ & \verb+Expr+ \token{!=} \verb+Expr+\\
\end{syntax}

\paragraph{Example.}

The following example illustrates an equality expression:

\lstinputlisting{../examples/ch6/eg_4.whiley}

This function checks whether a given integer is contained in a list of integers.  This is done by iterating each element of the list and comparing it against the given item.

% =======================================================================
% Invocation Expression
% =======================================================================

\section{Invoke Expressions}
\label{c_expr_invoke}

\begin{syntax}
  \verb+InvokeExpr+ & $::=$ &\\
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Lambda Expression
% =======================================================================

\section{Lambda Expressions}
\label{c_expr_lambda}

\begin{syntax}
  \verb+LambdaExpr+ & $::=$ &\\
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Logical Expressions
% =======================================================================

\section{Logical Expressions}
\label{c_expr_logical}

\begin{syntax}
  \verb+LogicalExpr+ & $::=$ &\\
  & $|$ & \verb+LogicalNotExpr+\\
  & $|$ & \verb+LogicalBinaryExpr+\\
  & $|$ & \verb+LogicalQuantExpr+\\
\end{syntax}


% =======================================================================
% Logical Not Expression
% =======================================================================

\subsection{Not Expressions}
\label{c_expr_logical_not}

\begin{syntax}
\verb+LogicalNotExpr+ & $::=$ & \token{!}\ \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Logical Binary Expressions
% =======================================================================

\subsection{Connective Expressions}
\label{c_expr_logical_binary}

A logical connective operates on values of \lstinline{bool} type (\S\ref{c_types_bool}) to produce another \lstinline{bool} value.  The {\em if-and-only-if (iff)} operator, \lstinline{<==>}, returns \lstinline{true} if either both operands are \lstinline{true} or both are \lstinline{false}.  The {\em implication} operator, \lstinline{==>}, returns \lstinline{true} if either the left operand is \lstinline{false}, or both operands are \lstinline{true}.  The {\em logical OR} operator returns \lstinline{true} if either operand is \lstinline{true}, whilst the {\em logical AND} operator returns \lstinline{true} if both operands are \lstinline{true}.

\begin{syntax}

  \verb+LogicalBinaryExpr+ & $::=$ & \verb+UnitExpr+ \big(\ \token{<==>} $|$ \token{==>} $|$ \token{\&\&} $|$ \token{||}\ \big) \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.}  The following examples illustrate some of the logical operators:

\lstinputlisting{../examples/ch6/eg_2.whiley}

The function \lstinline{implies()} implements the well-known equivalence between implication and logical OR.  The function \lstinline{iff()} implements the well-known equivalence between implication and iff.

% =======================================================================
% Quantifier Expressions
% =======================================================================

\subsection{Quantifier Expressions}
\label{c_expr_quantifier}

\begin{syntax}
\verb+LogicalQuantExpr+ & $::=$ & \big(\ \token{no} $|$ \token{some} $|$
\token{all}\ \big)\ \token{\{}\\
&&\ \verb+Ident+ \token{in} \verb+UnitExpr+ \big( \token{,}\ \verb+Ident+\
\token{in}\ \verb+UnitExpr+\ \big)$^*$\\
&&  \token{|}\ \verb+Expr+\ \token{\}}\\
\end{syntax}

\paragraph{Description.}

\paragraph{Examples.}

\paragraph{Notes.} 

% =======================================================================
% List Expressions
% =======================================================================

\section{List Expressions}
\label{c_expr_list}

\begin{syntax}
  \verb+ListExpr+ & $::=$ &\\
  & $|$ & \verb+ListLengthOfExpr+\\
  & $|$ & \verb+ListAccessExpr+\\
  & $|$ & \verb+ListAppendExpr+\\
  & $|$ & \verb+ListRangeExpr+\\
  & $|$ & \verb+ListConstructorExpr+\\
\end{syntax}

% =======================================================================
% LengthOf Expression
% =======================================================================

\subsection{LengthOf Expressions}
\label{c_expr_lengthof}

\begin{syntax}
\verb+ListLengthOfExpr+ & $::=$ & \token{|}\ \verb+Expr+\ \token{|}\\
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% List Access Expressions
% =======================================================================

\subsection{Access Expressions}
\label{c_expr_list_access}

\begin{syntax}
  \verb+ListAccessExpr+ & $::=$ & \verb+UnitExpr+\\
   &  \big( &\token{[}\ \verb+Expr+\ \token{]}\\
   & $|$ & \token{[}\ \verb+Expr+\ \token{..}\ \verb+Expr+\ \token{]}\\
   & \big)$^+$&\\
\end{syntax}

\paragraph{Description.}

The {\em arrow operator} returns a field of the value referenced by the argument.

\paragraph{Examples.}

\paragraph{Notes.} The arrow operation ``\lstinline{e->f}'' is a short-hand notation for ``\lstinline{(*e).f}'' and can be used when \lstinline{e} has effective record type (\S\ref{c_types_effective_records}).

% =======================================================================
% Append Expressions
% =======================================================================

\subsection{Append Expressions}
\label{c_expr_append}

An append expression accepts two lists arguments and produces a value of list type.  The append operator, \lstinline{++}, concatenates the argument lists together, producing a list constructed from those elements of the first argument (in order) followed by those of the second argument (in order).

\begin{syntax}
  \verb+ListAppendExpr+ & $::=$ & \verb+UnitExpr+\ \big(\ \token{++}\
  \verb+UnitExpr+\ \big)$^*$\\
\end{syntax}

\paragraph{Examples.} The following example illustrates the list append operator:

\lstinputlisting{../examples/ch6/eg_8.whiley}

This function constructs a list containing the integer values from \lstinline{start} up to (but not including) \lstinline{end}.  The list append operator is used to construct the list, starting initially from the empty list.

% =======================================================================
% Range Expressions
% =======================================================================

\subsection{Range Expressions}
\label{c_expr_range}

A range expression accepts two integer arguments and produces a value of integer list type.  The {\em range operator} constructs the list of integer values from the first argument up to (but not including) the last.

\begin{syntax}
  \verb+ListRangeExpr+ & $::=$ & \verb+UnitExpr+\ \token{..}\ \verb+UnitExpr+\\
\end{syntax}

\paragraph{Examples.}  The following illustrates the range operator:

\lstinputlisting{../examples/ch6/eg_9.whiley}

This function sums the integers between \lstinline{start} and \lstinline{end}.  The range operator is used to construct the list to be iterated over.

\paragraph{Notes.}  If the start of a range expression is greater than its end, the empty list is returned.

% =======================================================================
% List Expression
% =======================================================================

\subsection{Constructor Expressions}
\label{c_expr_list_constructor}

\begin{syntax}
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Record Expressions
% =======================================================================

\section{Record Expressions}
\label{c_expr_record}

% =======================================================================
% Field Access Expressions
% =======================================================================

\subsection{Field Access Expressions}
\label{c_expr_field_access}

\begin{syntax}
  \verb+FieldAccessExpr+ & $::=$ & \verb+UnitExpr+\\
   &  \big( &\token{.}\ \verb+Ident+\ \big[\ \token{(}\ \verb+ArgsList+\ \token{)}\ \big]\\
   & $|$ & \token{->}\ \verb+Ident+\ \big[\ \token{(}\ \verb+ArgsList+\ \token{)}\ \big]\\
   & \big)$^+$&\\
&&\\
\verb+ArgsList+ & $::=$ & \big[\ \verb+UnitExpr+\ \big(\ \token{,}\ \verb+UnitExpr+\ \big)$^*$\ \big]\\
\end{syntax}

\paragraph{Description.}

The {\em arrow operator} returns a field of the value referenced by the argument.

\paragraph{Examples.}

\paragraph{Notes.} The arrow operation ``\lstinline{e->f}'' is a short-hand notation for ``\lstinline{(*e).f}'' and can be used when \lstinline{e} has effective record type (\S\ref{c_types_effective_records}).


% =======================================================================
% Record Expression
% =======================================================================

\subsection{Record Constructors}
\label{c_expr_record_constructor}

\begin{syntax}
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Reference Expressions
% =======================================================================
\section{Reference Expressions}

% =======================================================================
% New Expression
% =======================================================================

\subsection{New Expressions}
\label{c_expr_new}

\begin{syntax}
\verb+NewExpr+ & $::=$ & \token{new}\ \verb+UnitExpr+\\
\end{syntax}

\paragraph{Example.}

\paragraph{Notes.}

% =======================================================================
% Dereference Expressions
% =======================================================================

\subsection{Dereference Expressions}
\label{c_expr_dereference}

A {\em dereference expression} accepts an argument of reference type and returns a value (or element) of the reference's target type.  The {\em dereference operator} returns the value referenced by the argument.  

\begin{syntax}
  \verb+DereferenceExpr+ & $::=$ & \token{*}\ \verb+TermExpr+\\\
  & $|$ & \verb+TermExpr+\ \token{->}\ \verb+Identifier+\\
\end{syntax}

\paragraph{Example.} The following illustrates the dereference operator:

\lstinputlisting{../examples/ch6/eg_14.whiley}

This function traverses a linked list counting the number of links it contains.  The arrow operator is used to access the next link in the chain.

\paragraph{Notes.}

% =======================================================================
% Term Expressions
% =======================================================================

\section{Terminal Expressions}
\label{c_expr_term}

A {\em terminal expression} is one which can terminate an expression tree (though does not necessarily do so).  For example, a numeric literal represents a terminal node in an expression tree.

\begin{syntax}
  \verb+TermExpr+ & $::=$ & \verb+Ident+\\
  & $|$ & \verb+Literal+\\
  & $|$ & \token{(}\ \verb+Expr+\ \token{)}\\
\end{syntax}

