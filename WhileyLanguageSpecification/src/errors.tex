\chapter{Error Messages}

{\bf Note:} need to distinguish the different kinds of error; e.g. type errors versus other errors?

\section{Parse Errors}

\section{Declarations}

\subsection{``Cyclic Constant Declaration'' (301)}

A {\em cyclic constant declaration} occurs when a \gls{constant_declaration} refers to itself, either {\em directly} or {\em indirectly}.  This is an error because constants must be evaluated at \gls{compile_time}.

\paragraph{Example.}  The following illustrates several cyclic constant declarations:

\begin{lstlisting}
constant const1 is 1 + const1

constant const2 is 1 + const3
constant const3 is 1 + const2
\end{lstlisting}
Here, all three constant declarations are cyclic.  The declaration for \lstinline{const1} has a {\em direct} cycle, because its definition refers to itself.  The declaration for \lstinline{const2} has an indirect cycle, because its definition refers to \lstinline{const3} which, in turn, refers back to \lstinline{const2}.

\section{Expressions}

%\subsection{``Invalid File Access'' (000)}

%\subsection{``Invalid Package Access'' (000)}

%\subsection{``Resolution Error'' (000)}

\subsection{``Variable Possibly Uninitialised'' (000)}
\label{c_err_var_uninitialised}
A {\em variable possibly uninitialised} occurs when a variable may be used without being defined.  That is, when a simple path exists through the control-flow graph of a function or method from that variable's declaration to a use which contains no definition for that variable.  This error is reported as part of the {\em definite assignment} checking performed during compilation (see~\S\ref{c_definite_assignment}).

\paragraph{Example.}  The following illustrates a variable which is possibly uninitialised:

\begin{lstlisting}
function f(int x) => int:
   int y
   return x + y
\end{lstlisting}

Here, variable \lstinline{y} is definitely uninitialised in the expression ``\lstinline{x + y}''.  For more examples of variables which are possibly uninitialised, see~\S\ref{c_definite_assignment}.

\subsection{``Ambiguous Coercion'' (000)}

An {\em ambiguous coercion} occurs when the target of a cast expression is uncertain.  That is, when attempting to cast a value to a given type \lstinline{T}, but there is more than one way this can be achieved.  This error is reported as part of the {\em coercion check} performed during compilation.

\paragraph{Example.}  The following illustrates an ambiguous coercion:

\begin{lstlisting}
type Ambiguous is { int f1, real f2} | { real f1, int f2 }

function f(int x, int y) -> Ambiguous:
   return (Ammbiguous) {f1: x, f2: y}
\end{lstlisting}

The cast is ambiguous here because it's unclear whether, for example, \lstinline|{f1: 1, f2: 2}| should become \lstinline|{f1: 1.0, f2: 2}| or \lstinline|{f1: 1, f2: 2.0}|.

\section{Control Flow}

\subsection{``Invalid LVal'' (000)}

An {\em invalid lval} error occurs when an invalid expression is used on the left-hand side of an assignment.  Only expressions which are also lval's maybe used in such a situation  (see~\S\ref{c_stmts_lval}).

\paragraph{Example.}  The following illustrates two invalid lval's:

\begin{lstlisting}
function f(int x):
   1 = x   // constant not valid lval
   x+1 = x // arithmetic expression not valid    
\end{lstlisting}

The first assignment statement is invalid because one cannot assign to a constant.  The second is invalid because one cannot assign to an arithmetic expression.

\subsection{``Invalid Destructuring LVal'' (000)}

An {\em invalid destructuring lval} occurs when a destructuring assignment is used on the left-hand side, but the right-hand side returns an incorrect number of values.

\paragraph{Example.}  The following illustrates an invalid destructuring LVal:

\begin{lstlisting}
function f(int x, int y) -> int:
    return x+y

function g(int x, int y) -> int:
    x,y = f(x,y)
    return x - y
\end{lstlisting}

Here, the invocation of \lstinline{f()} in \lstinline{g()} uses an invalid destructuring assignment because \lstinline{f()} returns one value, the assignment expects two.

\subsection{``Break Outside of Loop'' (000)}

A {\em break outside loop} occurs when a \lstinline{break} statement is given which is not contained within one or more loops.  This is an error because the break statement is used specifically to exit a loop early, and must be contained within the loop to be exited.  

\paragraph{Example.}  The following illustrates a break outside of a loop:

\begin{lstlisting}
function f(int x) -> int:
   break
   return x
\end{lstlisting}

Here, the \lstinline{break} statement is meaningless as it is not associated with a loop.

\subsection{``Unknown Variable'' (000)}

An {\em unknown variable} occurs when an attempt is made to access a variable which has not been declared in the current scope.  All variables must be declared before they can be used.

\paragraph{Example.}  The following illustrates an unknown variable:

\begin{lstlisting}
function f(int x) -> int:
   return x+y
\end{lstlisting}

Here, the \lstinline{return} statements refers to an unknown variable \lstinline{y}.  In contrast, the reference to variable \lstinline{x} is valid because \lstinline{x} has been declared within scope.

\subsection{``Unknown Function or Method'' (000)}

\subsection{``Variable Already Defined'' (000)}

A {\em variable redefinition} occurs when a variable is declared with a name matching another variable already in scope.  This is an error because it is not permitted for one variable to shadow another.

\paragraph{Example.}  The following illustrates an example of a variable redefinition:

\begin{lstlisting}
function add([int] xs, int v) => [int]:
    for k,v in xs:
        xs[k] = xs[k] + v
    return xs
\end{lstlisting}

Here, the \lstinline{for} loop attempts to declare a variable \lstinline{v}, but another variable \lstinline{v} was already declared as a parameter.

\subsection{``Duplicate Default Label'' (000)}
A {\em duplicate default label} occurs when a \lstinline{switch} statement includes more than one \lstinline{default} label.  This is an error because at most one \lstinline{default} is permitted.

\paragraph{Example.}  The following illustrates an example of a duplicate \lstinline{default} label:

\begin{lstlisting}
function f(int x):
    switch x:
        case 0:
            return 0
        default:
            return 1
        default:
            return 2
\end{lstlisting}

Here, the \lstinline{switch} statement has two \lstinline{default} labels.  This must be an error as, otherwise, it would be ambiguous as to which executed.

\subsection{``Duplicate Case Label'' (000)}
A {\em duplicate case label} occurs when a \lstinline{switch} statement includes more than one \lstinline{case} label matching the same value.  This is an error because at most one \lstinline{case} matching a given value is permitted.

\paragraph{Example.}  The following illustrates an example of a duplicate \lstinline{case} label:

\begin{lstlisting}
function f(int x):
    switch x:
        case 0:
            return 0
        case 0,1:
            return 1
        default:
            return 2
\end{lstlisting}

Here, the \lstinline{switch} statement has two \lstinline{case} labels, both of which match the value \lstinline{0}.  This must be an error as, otherwise, it would be ambiguous as to which executed.

\subsection{``Unreachable Code'' (000)}

In a function or method, {\em unreachable code} arises when no possible execution path could reach them.  

\paragraph{Example.} The following illustrates some unreachable code:

\begin{lstlisting}
function abs(int x):
    //
    if x < 0:
        return -x
    else:
        return x
    //
    return 0 // unreachable
\end{lstlisting}

Here, the final \lstinline{return} statement can never be reached by any execution path through the \lstinline{abs()} function.  This is considered an error because it indicates something undesirable which may not have been intended.

\subsection{``Missing Return Value'' (000)}

\subsection{``Branch Always Taken'' (000)}

\section{Functions (000)}

\subsection{``Reference Not Permitted in Function'' (000)}

\subsection{``Method Invocation Not Permitted In Function'' (000)}

\subsection{``Reference Access Not Permitted in Function'' (000)}

\subsection{``Return from Void'' (000)}
	
\section{Types (000)}

\subsection{``Subtype Error'' (000)}

\subsection{``Incomparable Operands'' (000)}

\subsection{``Record Type Required'' (000)}

\subsection{``Record Missing Field'' (000)}

