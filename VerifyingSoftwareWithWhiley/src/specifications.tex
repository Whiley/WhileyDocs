\chapter{Specifying Functions and Data}
Introduction to what pre-/post-conditions are, and the important aspects of logic (e.g. quantification).  Clarify that there are different levels of specification, ranging from the minimum to illustrate lack of runtime error to the complete specification that a function is correct.

\section{Preconditions and Postconditions}
A {\em precondition} is a condition over the parameters of a function
that is required to be true when the function is called.  The body of
the function can then use this to make assumptions about the possible
values of the parameters.  Likewise, a {\em postcondition} is a
condition over the return values of a function which is required to be
true after the function is called.  As a very simple example, consider
the following function which accepts a positive integer and returns a
non-negative integer (i.e. natural number):
\begin{lstlisting}
function decrement(int x) => (int y) 
// Parameter x must be greater than zero
requires x > 0
// Return must be greater or equal to zero
ensures y >= 0:
    //
    return x - 1
\end{lstlisting}
Here, the \lstinline{requires} and \lstinline{ensures} clauses define
the function's precondition and postcondition.  With verification
enabled, the Whiley compiler will verify that the
implementation of this function meets its specification.  In fact, we
can see this for ourselves by manually constructing an appropriate
{\em verification condition} (that is, a logical condition whose truth
establishes that the implementation meets its specification).  In this
case, the appropriate verification condition is
 \lstinline{x > 0 ==> x-1 >= 0}.  Unfortunately, although constructing a verification
condition by hand was possible in this case, in general it's difficult
if not impossible for more complex functions.

The Whiley compiler reasons about functions by exploring the different
control-flow paths through their bodies.  Furthermore, as it learns
more about the variables used in the function, it automatically takes
this into account.  For example:
\begin{lstlisting}
function abs(int x) => (int y)
// Return value cannot be negative
ensures y >= 0:
    //
    if x >= 0:
        return x
    else:
        return -x
\end{lstlisting}
The Whiley compiler verifies that the implementation of this function
meets its specification.  At this point, it is worth considering in
more detail what this really means.  Since the Whiley compiler
performs verification at {\em compile-time}, it does not consider
specific values when reasoning about a function's implementation.
Instead, it considers all possible input values for the function which
satisfy its precondition.  In other words, when the Whiley compiler
verifies a function's implementation meets its specification, this
means it does so {\em for all possible input values}.  

\section{Data Type Invariants}

The above illustrates a function specification given through explicit pre- and
post-conditions.  However, we may also employ {\em constrained types}
to simplify it as follows:

\begin{lstlisting}
type nat is (int n) where n >= 0
type pos is (int p) where p > 0

function f(pos x) => (nat n)
// Return must differ from parameter
ensures n != x:
    //
    return x-1
\end{lstlisting}

Here, the \lstinline{type} declaration includes a \lstinline{where}
clause constraining the permissible values for the type ($\$$
represents the variable whose type this will be).  Thus,
\lstinline{nat} defines the type of non-negative integers (i.e. the
natural numbers).  Likewise, \lstinline{pos} gives the type of
positive integers and is implicitly a subtype of \lstinline{nat}
(since the constraint on \lstinline{pos} implies that of
\lstinline{nat}).  We consider that good use of constrained types is
critical to ensuring that function specifications remain as readable
as possible.

The notion of type in Whiley is more fluid than found in typical
languages.  In particular, if two types ${\tt T_1}$ and ${\tt T_2}$
have the same {\em underlying} type, then ${\tt T_1}$ is a subtype of
${\tt T_2}$ iff the constraint on ${\tt T_1}$ implies that of ${\tt
  T_2}$.  Consider the following:

\begin{lstlisting}
 type anat is (int x) where x >= 0
 type bnat is (int x) where 2*x >= x

 function f(anat x) => bnat:
     return x
\end{lstlisting}
In this case, we have two alternate (and completely equivalent)
definitions for a natural number (we can see that \lstinline{bnat} is
equivalent to \lstinline{anat} by subtracting \lstinline{x} from both sides).
The Whiley compiler is able to reason that these types are equivalent
and statically verifies that this function is correct.
\section{Language}
\subsection{Basics}
\subsection{Quantifiers}
\subsection{Functions}
\section{Weak vs Strong Specifications}
\section{Static vs Dynamic Checking}
\section{Partial vs Total Correctness}