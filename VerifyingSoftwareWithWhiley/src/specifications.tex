\chapter{Specifying Functions and Data}
In this chapter, we embark upon the first step in the process of establishing that a program is (in some sense) correct.  That is, to determine exactly what our program is supposed to do.  To this end, we will learn how to write {\em specifications} for our programs which precisely describe their behaviour.  

In doing this, we must acknowledge that precisely describing a program's behaviour is extremely challenging and, oftentimes, we want only to specify some {\em important aspect} of its permitted behaviour.  This can give us many of the benefits from specification without all of the costs.  

While we will consider how to write specifications in this chapter, we will largely ignore the issue of determining whether our programs meet their specifications.  Although this is an important part of the process, it is also challenging and we will require several chapters to fully explore how this is done.

{\em Clarify that there are different levels of specification, ranging from the minimum to illustrate lack of runtime error to the complete specification that a function is correct.}

\section{Overview}

Specifying a program in Whiley consists of at least two separate activities;  firstly, we provide appropriate specifications (called {\em invariants}) for any data types we have defined;  secondly, we provide specifications in the form of {\em pre-} and {\em post-conditions} for any functions or methods defined.

Of course, having specified our program, we want to establish that it meets its specification.  Or, in other words, that every function and method meets its specification.  This is itself quite a challenge and, furthermore, will often uncover critical flaws in our program.  For now, we will ignore the question of whether our program meets its specification, and focus on the question of how you actually write a specification.

\subsection{Preconditions and Postconditions}
To specify a function or method in Whiley we must provide an appropriate {\em precondition} and {\em postcondition}.  A precondition is a condition over the parameters of a function that is required to be true when the function is called.  The body of the function can then use this to make assumptions about the possible values of the parameters.  Likewise, a postcondition is a condition over the return values of a function which is required to be true after the function is called.  As a very simple example, consider the following function which accepts a positive integer and returns a
non-negative integer (i.e. a natural number):
\begin{lstlisting}
function decrement(int x) => (int y) 
// Parameter x must be greater than zero
requires x > 0
// Return must be greater or equal to zero
ensures y >= 0:
    //
    return x - 1
\end{lstlisting}
Here, the \lstinline{requires} and \lstinline{ensures} clauses define the function's precondition and postcondition.  Informally, we can see that this function does meet its specification.  Unfortunately, for larger programs it is very difficult to be sure that informal reasoning like this is correct.  In later chapters, we will see how the Whiley system can automatically check that a function or method meets its specifications for us.

The Whiley compiler reasons about functions by exploring the different
control-flow paths through their bodies.  Furthermore, as it learns
more about the variables used in the function, it automatically takes
this into account.  For example:
\begin{lstlisting}
function abs(int x) => (int y)
// Return value cannot be negative
ensures y >= 0:
    //
    if x >= 0:
        return x
    else:
        return -x
\end{lstlisting}
The Whiley compiler verifies that the implementation of this function
meets its specification.  At this point, it is worth considering in
more detail what this really means.  Since the Whiley compiler
performs verification at {\em compile-time}, it does not consider
specific values when reasoning about a function's implementation.
Instead, it considers all possible input values for the function which
satisfy its precondition.  In other words, when the Whiley compiler
verifies a function's implementation meets its specification, this
means it does so {\em for all possible input values}.  

\subsection{Data Type Invariants}

The above illustrates a function specification given through explicit pre- and
post-conditions.  However, we may also employ {\em constrained types}
to simplify it as follows:

\begin{lstlisting}
type nat is (int n) where n >= 0
type pos is (int p) where p > 0

function f(pos x) => (nat n)
// Return must differ from parameter
ensures n != x:
    //
    return x-1
\end{lstlisting}

Here, the \lstinline{type} declaration includes a \lstinline{where}
clause constraining the permissible values for the type ($\$$
represents the variable whose type this will be).  Thus,
\lstinline{nat} defines the type of non-negative integers (i.e. the
natural numbers).  Likewise, \lstinline{pos} gives the type of
positive integers and is implicitly a subtype of \lstinline{nat}
(since the constraint on \lstinline{pos} implies that of
\lstinline{nat}).  We consider that good use of constrained types is
critical to ensuring that function specifications remain as readable
as possible.

The notion of type in Whiley is more fluid than found in typical
languages.  In particular, if two types ${\tt T_1}$ and ${\tt T_2}$
have the same {\em underlying} type, then ${\tt T_1}$ is a subtype of
${\tt T_2}$ iff the constraint on ${\tt T_1}$ implies that of ${\tt
  T_2}$.  Consider the following:

\begin{lstlisting}
 type anat is (int x) where x >= 0
 type bnat is (int x) where 2*x >= x

 function f(anat x) => bnat:
     return x
\end{lstlisting}
In this case, we have two alternate (and completely equivalent)
definitions for a natural number (we can see that \lstinline{bnat} is
equivalent to \lstinline{anat} by subtracting \lstinline{x} from both sides).
The Whiley compiler is able to reason that these types are equivalent
and statically verifies that this function is correct.
\section{Language of Specifications}
\subsection{Basics}
\subsection{Quantifiers}
\subsection{Functions}
\section{Weak vs Strong Specifications}
\section{Static vs Dynamic Checking}
\section{Partial vs Total Correctness}

\section{Exercises}

\begin{ex}
The function \lstinline{neg()} returns the arithmetic negation of a value.
For example, \lstinline{neg(1) = -1}.  An implementation of
this function is given as follows:
\begin{lstlisting}
function neg(int x) => (int r):
    return -x
\end{lstlisting}
Provide an appropriate {\em post-condition} for this function.
\end{ex}

\begin{ex}
The \lstinline{swap} function accepts to integers and returns them
with their order swapped.  The signature for the function is:
\begin{lstlisting}
function swap(int x, int y) => (int a, int b):
    ...
\end{lstlisting}
Provide an appropriate specification and implementation for this function.
\end{ex}

\begin{ex}

A {\em natural} number is an integer which is greater-than-or-equal to
zero.  The following function adds three natural numbers together to produce a natural number:
\begin{lstlisting}
function sum3(int x, int y, int z) => (int r)
// No parameter can be negative
requires ...
// Return value cannot be negative
ensures ...:
    //
    return x + y + z
\end{lstlisting}
Complete the given \lstinline{requires} and \lstinline{ensures}
clauses based on the given English descriptions.

\end{ex}

\begin{ex}
  The following function computes the absolute difference between two values:

\begin{lstlisting}
function diff(int x, int y) => (int r):
    //
    if x > y:
        return x - y
    else:
        return y - x
\end{lstlisting}

A {\em pre-condition} of this function is that parameter \lstinline{x}
is between \lstinline{0} and \lstinline{255} (inclusive) and,
likewise, that variable \lstinline{y} is between \lstinline{-128} and
\lstinline{127} (inclusive).  Provide a partial specification for
this function which constraints the ranges of the input and output
variables as tightly as possible.
\end{ex}

\begin{ex}
The Gregorian calendar is the most widely used organisation of dates.
A well-known saying for remembering the number of days in each month
is the following:
\begin{quote}
``Thirty days hath September, April, June and November.  All the rest
have thirty-one, except February which has twenty-nine ...''
\end{quote}
Note, in this exercise, we will ignore the issue of leap years.  A
simple function for returning a date can be defined as follws:
\begin{lstlisting}
constant Jan is 1
constant Feb is 2
constant Mar is 3
constant Apr is 4
constant May is 5
constant Jun is 6
constant Jul is 7
constant Aug is 8
constant Sep is 9
constant Oct is 10
constant Nov is 11
constant Dec is 12

function getDate() => (int day, int month, int year):
    ...
\end{lstlisting}
Provide a specification for this function to ensure the returned date
is valid (ignoring leap years).  Furthermore, provide a simple
implementation which meets this specification.
\end{ex}

\begin{ex}
A well-known puzzle is that of the three water jugs.  In this
exercise, we will consider a cut down version of this which consists
of two water jugs: a small jug (containing three litres) and a large
jug (containing five litres).  The goal is to complete the
specification of the following function for pouring water from the
small jug into the large jug:

\begin{lstlisting}
function pourSmall2Large(int smallJug, int largeJug) => 
                        (int smallJugAfter, int largeJugAfter)
// The small jug holds between 0 and 3 litres (before)
requires ...
// The large jug holds between 0 and 5 litres (before)
requires ...
// The small jug holds between 0 and 3 litres (after)
ensures ...
// The large jug holds between 0 and 5 litres (after)
ensures ...
// The amount in both jugs is unchanged by this function
ensures ...
// Afterwards, either the small jug is empty or the large jug is full
ensures ...:
    //
    if smallJug + largeJug <= 5:
        // indicates we're emptying the small jug
        largeJug = largeJug + smallJug
        smallJug = 0
    else:
        // indicates we're filling up the medium jug    
        smallJug = largeJug + smallJug
        largeJug = 5
    // Done
    return smallJug, largeJug
\end{lstlisting}
Complete the missing \lstinline{requires} and \lstinline{ensures}
clauses based on the given English descriptions.  Does the implementation meet the given specification?
\end{ex}
