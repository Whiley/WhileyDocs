\chapter{Introduction}
When we write software, we have in mind some idea of what it is supposed to do.  When we've finished our program, we might run it to see whether it appears to do the right thing.  However, as anyone who has ever written a program will know: {\em this is not always enough!}  Even if our program appears to work after a few tests, there is still a good chance it will go wrong for other inputs we have not yet tried.  The question, then, is: {\em how can we be certain that our program is correct?}

In trying to determine whether our program is correct, our first goal is to determine precisely what it should do.  In writing our program, we may not have had a clear idea of this from the outset.  Therefore, we need to determine a {\em specification} for our program.  This is a precise description of what the program should and should not do.  Only with this can we begin to consider whether or not our program actually does the right thing.


\section{Infamous Software Failures}

Introduce some classic historical bugs, and emphasis that we want to reduce these as much as possible.  There are lots of good examples, some of which are not coding failures but failures of understanding the requirements, etc.

Numerous important software systems have failed due to program bugs. Historic examples include the Therac-25 disaster where a computer-operated X-ray machine gave lethal doses to patients, the 1988 worm which wreaked havoc on the internet by exploiting a buffer overrun, and the (unmanned) Ariane 5 rocket which exploded shortly after launch because of an integer overflow (see this video and this list for more).

\section{Programming Languages}

Modern programming languages, such as Java and C\#, eliminate fairly simple classes of error (so-called type errors) through the process of type checking; however, they cannot detect more complex problems, such as the potential for a divide-by-zero error. Type checking has been used for a long time in programming languages, historical examples of which include: ALGOL, Pascal, Modula-2, C, C++, Java, C\# and more.

\section{Whiley}
The Whiley programming language has been in active development since
2009.  The language was designed specifically to help the programmer
eliminate bugs from his/her software.  The key feature is that Whiley
allows programmers to write {\em specifications} for their functions,
which are then checked by the compiler.  For example, here is the
specification for the \lstinline{max()} function which returns the
maximum of two integers:

\begin{lstlisting}
function max(int x, int y) => (int z)
// must return either x or y
ensures x == z || y == z
// return must be as large as x and y
ensures x <= z && y <= z:
    // implementation
    if x > y:
        return x
    else:
        return y
\end{lstlisting}

Here, we see our first piece of Whiley code.  This declares a function
called \lstinline{max} which accepts two integers \lstinline{x} and
\lstinline{y}, and returns an integer \lstinline{z}.  The body of the
function simply compares the two parameters and returns the largest.
The two \lstinline{requires} clauses form the function's {\em
  post-condition}, which is a guarantee made to any caller of this
function.  In this case, the \lstinline{max} function guarantees to
return one of the two parameters, and that the return will be as large
as both of them.  In plain English, this means it will return the
maximum of the two parameter values.

When verification is enabled the Whiley compiler will check that every
function meets its specification.  For our \lstinline{max()} function,
this means it will check that body of the function guarantees to
return a value which meets the function's post-condition.  To do this,
it will explore the two execution paths of the function and check each
one separately.  If it finds a path which does not meet the
post-condition, the compiler will report an error.  In this case, the
\lstinline{max()} function above is implemented correctly and so it
will find no errors.  The advantage of providing specifications is
that they can help uncover bugs and other, more serious, problems
earlier in the development cycle.  This leads to software which is
both more reliable and more easily maintained (since the
specifications provide important documentation).

\subsection{Objectives}
